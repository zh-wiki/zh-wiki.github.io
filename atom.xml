<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhou&#39;s Wiki</title>
  
  
  <link href="https://zh-wiki.github.io/atom.xml" rel="self"/>
  
  <link href="https://zh-wiki.github.io/"/>
  <updated>2021-01-30T08:33:17.763Z</updated>
  <id>https://zh-wiki.github.io/</id>
  
  <author>
    <name>Zhoujunwei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Welcome Zhou jun wei&#39;s Wiki Site</title>
    <link href="https://zh-wiki.github.io/undefined/index/"/>
    <id>https://zh-wiki.github.io/undefined/index/</id>
    <published>2021-01-30T08:33:17.763Z</published>
    <updated>2021-01-30T08:33:17.763Z</updated>
    
    <content type="html"><![CDATA[<img src="/undefined/index/index.jpg" alt="维基百科" style="zoom:200%;">]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/undefined/index/index.jpg&quot; alt=&quot;维基百科&quot; style=&quot;zoom:200%;&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>图片数据格式与转换</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/</id>
    <published>2021-01-21T01:52:03.000Z</published>
    <updated>2021-01-30T08:33:26.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Camera-Sensor-数据格式"><a href="#Camera-Sensor-数据格式" class="headerlink" title="Camera Sensor 数据格式"></a>Camera Sensor 数据格式</h1><hr><h2 id="Sensor-出图简介"><a href="#Sensor-出图简介" class="headerlink" title="Sensor 出图简介"></a>Sensor 出图简介</h2><p>外部光线穿过lens后，经过color filter滤波后照射到Sensor面上， Sensor将从lens上传导过来的光线转换为电信号，再通过内部的DA转换为数字信号。</p><ul><li>如果sensor内部集成ISP, 那么sensor可以直接生成支持的格式，如 YUV , JPEG ,RGB 。</li><li>如果Sensor没有集成ISP，则传输到baseband（基带=未经处理的电信号），此时的数据格式是RAW RGB data。</li></ul><p>综上所述sensor出图支持以下格式</p><style type="text/css">.tg  {border-collapse:collapse;border-color:#ccc;border-spacing:0;}.tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}.tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}.tg .tg-baqh{text-align:center;vertical-align:top}.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}</style><table class="tg"><thead>  <tr>    <th class="tg-amwm">数据格式</th>    <th class="tg-amwm">描述</th>  </tr></thead><tbody>  <tr>    <td class="tg-baqh"><span style="font-weight:400;font-style:normal">RAW RGB</span></td>    <td class="tg-0lax"><span style="font-weight:400;font-style:normal">luma (Y) + chroma (UV) 格式， 一般情况下sensor支持YUV422格式，即数据格式是按Y-U-Y-V次序输出的</span></td>  </tr>  <tr>    <td class="tg-baqh">RGB</td>    <td class="tg-0lax">传统的红绿蓝格式，比如RGB565，其16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感。</td>  </tr>  <tr>    <td class="tg-baqh">YUV</td>    <td class="tg-0lax">sensor的每一像素对应一个彩色滤光片，滤光片按Bayer pattern分布。将每一个像素的数据直接输出，即RAW RGB data</td>  </tr>  <tr>    <td class="tg-baqh">JPEG</td>    <td class="tg-0lax">有些sensor，特别是低分辨率的，其自带JPEG engine，可以直接输出压缩后的jpg格式的数据</td>  </tr></tbody></table><h2 id="RAW-RGB-数据格式"><a href="#RAW-RGB-数据格式" class="headerlink" title="RAW RGB 数据格式"></a>RAW RGB 数据格式</h2><p>通过上面的介绍，可以指导 raw RGB 是通过内部的DA转换为数字信号。因为sensor上每个像素只采集特定颜色的光的强度，因此sensor每个像素只能为R或G或B，形成的数据就成为了rawRGB数据。</p><p>rawRGB数据是sensor的经过光电转换后通过ADC采样后直接输出数据，是未经处理过的数据，表示sensor接受到的各种光的强度。</p><p>rawRGB数据排列格式有四种</p><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122105424166.png" alt="rawRGB数据排列格式"></p><p>由上图可以看出，每一种格式的rawRGB数据的G分量都是B、R分量的两倍，是因为人眼对于绿色的更加敏感，所以加重了其在感光点的权重，增加了对绿色信息的采样。</p><h2 id="RGB-数据格式"><a href="#RGB-数据格式" class="headerlink" title="RGB 数据格式"></a>RGB 数据格式</h2><p> 在数字化的时代，需要一种标准来量化自然界的各种颜色。RGB就是一种在数字化领域表示颜色的标准，也称作一种色彩空间，通过用三原色R、G、B的不同的亮度值组合来表示某一种具体的颜色。</p><p>注意：<font color="red">RGB里面存的是颜色的亮度值，而不是色度值</font></p><p> 目前人类发明的所有彩色的输入输出设备，本质上都只支持RGB数据。哪怕设备允许YUV的输入输出，那也是经过内部的数据转换而间接支持。</p><p>常用的RGB格式如下表所示</p><style type="text/css">.tg  {border-collapse:collapse;border-color:#ccc;border-spacing:0;}.tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}.tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}.tg .tg-baqh{text-align:center;vertical-align:top}.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}.tg .tg-0lax{text-align:left;vertical-align:top}</style><table class="tg"><thead>  <tr>    <th class="tg-amwm">格式</th>    <th class="tg-amwm">描述</th>  </tr></thead><tbody>  <tr>    <td class="tg-baqh"><span style="font-weight:400;font-style:normal">RGB565</span></td>    <td class="tg-0lax"><span style="font-weight:400;font-style:normal">每个像素用16位表示，RGB分量分别使用5位、6位、5位（常用也就是上说的RGB）</span></td>  </tr>  <tr>    <td class="tg-baqh"><span style="font-weight:400;font-style:normal">RGB555</span></td>    <td class="tg-0lax"><span style="font-weight:400;font-style:normal">每个像素用16位表示，RGB分量都使用5位（剩下1位不用）</span></td>  </tr>  <tr>    <td class="tg-baqh"><span style="font-weight:400;font-style:normal">RGB888</span></td>    <td class="tg-0lax">每个像素用24位表示，RGB分量各使用8位</td>  </tr>  <tr>    <td class="tg-baqh"><span style="font-weight:400;font-style:normal">RGB32</span></td>    <td class="tg-0lax">每个像素用32位表示，RGB分量各使用8位（剩下8位不用）</td>  </tr>  <tr>    <td class="tg-baqh"><span style="font-weight:400;font-style:normal">ARGB32</span></td>    <td class="tg-0lax">每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）。</td>  </tr></tbody></table><h2 id="YUV-数据格式"><a href="#YUV-数据格式" class="headerlink" title="YUV 数据格式"></a>YUV 数据格式</h2><h3 id="YUV-的基本概念以及作用"><a href="#YUV-的基本概念以及作用" class="headerlink" title="YUV 的基本概念以及作用"></a>YUV 的基本概念以及作用</h3><ol><li><p>YUV 的基本介绍</p><ul><li>YUV是一种色彩编码方法，Y表示亮度，U和V表示色度。只有Y就是黑白图像，再加上UV就是彩色图像了。YUV的一个好处就是让彩色系统和传统黑白系统很好的兼容，同时利用了人类视觉系统对亮度的敏感度比对色度高。</li><li>在一般应用中，人们所说的YUV就是YCbCr，常见应用如H.264/H.265码流、MPEG、JPEG等。</li><li>YCbCr中的Cb指蓝色色度分量，而Cr指红色色度分量。</li><li>YUV和RGB的相同点：都是用来表达颜色的数学方法；</li><li>YUV和RGB的不同点：对颜色的描述思路和方法不同。RGB将一个颜色拆解为3个纯色的亮度组合，YUV将一个颜色分解为一个亮度和2个色度的组合。</li></ul></li><li><p>为什么要有yuv，作用是什么</p><ul><li>YUV提取Y亮度信号，可以直接给黑白电视使用，兼容黑白电视</li><li>人眼对UV的敏感性小于亮度，这样我们适当减少uv的量，而不影响人的感官。所以才会有多种格式的 YUV描述，如420、422、444。</li><li>YUV格式可以比RGB格式储存空间小。</li></ul></li></ol><h3 id="YUV-的采样格式"><a href="#YUV-的采样格式" class="headerlink" title="YUV 的采样格式"></a>YUV 的采样格式</h3><style type="text/css">.tg  {border-collapse:collapse;border-color:#ccc;border-spacing:0;}.tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333;  font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;}.tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333;  font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}</style><table class="tg"><thead>  <tr>    <th class="tg-c3ow">采样方式</th>    <th class="tg-c3ow">描述</th>  </tr></thead><tbody>  <tr>    <td class="tg-9wq8"><span style="font-weight:400;font-style:normal">YUV 4:4:4 采样</span></td>    <td class="tg-0pky"><span style="font-weight:400;font-style:normal">全采样，对每个像素点的的YUV分量都进行采样，这样的三个分量信息量完整。</span></td>  </tr>  <tr>    <td class="tg-9wq8"><span style="font-weight:400;font-style:normal">YUV 4:2:2 采样</span></td>    <td class="tg-0pky"><span style="font-weight:400;font-style:normal">部分采样，可节省1/3存储空间和1/3的数据传输量。UV分量是Y分量采样的一半，Y分量和UV 分量按照2 : 1的比例采样。</span><br><span style="font-weight:400;font-style:normal">每采样过一个像素点，都会采样其Y分量，而U、V分量就会间隔一个采集一个。</span></td>  </tr>  <tr>    <td class="tg-9wq8">YUV 4:2:0 采样</td>    <td class="tg-0pky"><span style="font-weight:400;font-style:normal">部分采样，可节省1/2存储空间和1/2的数据传输量。</span><br><span style="font-weight:400;font-style:normal">YUV 420采样，并不是指只采样U分量而不采样V分量。</span><br><span style="font-weight:400;font-style:normal">在每一行扫描时，只扫描一种色度分量（U或者V），和Y分量按照2 : 1的方式采样。</span><br><span style="font-weight:400;font-style:normal">比如，第一行扫描时，YU 按照 2 : 1的方式采样，那么第二行扫描时，YV分量按照 2:1的方式采样。对于每个色度分量来说，它的水平方向和竖直方向的采样和Y分量相比都是2:1 。</span></td>  </tr></tbody></table><h3 id="YUV-的存储格式"><a href="#YUV-的存储格式" class="headerlink" title="YUV 的存储格式"></a>YUV 的存储格式</h3><p> YUV存储格式通常有两大类：打包（packed）格式和平面（planar）格式。前者将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素(macro-pixel)；而后者使用三个数组分开放 YUV 三个分量，就像是一个三维平面一样。</p><ol><li><p>YUV422 Planar (YUV422P 也称为I422)</p><p>这里，Y\U\V数据是分开存放的，每两个水平Y采样点，有一个U和一个V采样点，如下</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122142524656.png" alt="像素存储格式" style="zoom:67%;"><p>采用的是平面格式进行存储，先存储所有的 Y 分量，再存储所有的 U 分量，再存储所有的 V 分量</p><p>假如一个8*2像素的图像的该格式的存储分布如下图：</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122134914810.png" alt="像素存储图" style="zoom:50%;"></li><li><p>YuV422 packed 此格式有两种情况：分为YUYV格式和UYVY格式</p><p><strong>① YUYV 格式</strong></p><p>​        YUYV 格式是采用打包格式进行存储的，指每个像素点都采用 Y 分量，但是每隔一个像素采样它的UV分量。</p><p>​        假如一个8*2像素的图像的该格式的存储分布如下图：</p><p>​        <img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122141308804.png" alt="像素存储图" style="zoom:50%;"></p><p><strong>② UYVY 格式</strong></p><p>​      UYVY 格式也是采用打包格式进行存储，它的顺序和YUYV相反，先采用U分量再采样Y分量。</p><p>​      假如一个8*2像素的图像的该格式的存储分布如下图：     </p><p>​      <img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122141527886.png" alt="像素存储图" style="zoom:50%;"></p></li><li><p>YUV420 Planar (YUV420P)</p><p>这个格式跟YUV422 Planar 类似，但对于U和V的采样在水平和垂直方向都减少为2:1，根据采样规则如下</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122142255607.png" alt="存储格式" style="zoom: 67%;"><p>针对与 YUV420 Planar 这种格式又分为两种格式</p><ul><li><p>YU12 <strong>（也称为I420格式）</strong> 是先Y再U后V。</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122162153262.png" alt="image-20210122162153262" style="zoom:50%;"></li><li><p>YV12是先Y再V后U</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122162103477.png" alt="image-20210122162103477" style="zoom:50%;"></li></ul></li><li><p>YUV422 Semi-Planar (YUV422SP)</p><p>Semi 是“半”的意思，个人理解这个是半平面模式，这个格式的数据量跟YUV422 Planar的一样，但是U、V是交叉存放的。</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122162410022.png" alt="image-20210122162410022" style="zoom:50%;"></li><li><p>YUV420 Semi-Planar (YUV420SP)</p><p>这个格式的数据量跟YUV420 Planar的一样，但是U、V是交叉存放的。</p><p> NV12和NV21格式都属于 YUV420SP 类型。它也是先存储了Y分量，但接下来并不是再存储所有的U或者V分量，而是把UV分量交替连续存储。</p><ul><li><p>NV12是IOS中有的模式，它的存储顺序是先存Y分量，再UV进行交替存储。</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122162551543.png" alt="image-20210122162551543" style="zoom:50%;"></li><li><p>NV21是安卓中有的模式，它的存储顺序是先存Y分量，在VU交替存储。</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E5%9B%BE%E7%89%87%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E8%BD%AC%E6%8D%A2/image-20210122162620551.png" alt="image-20210122162620551" style="zoom:50%;"></li></ul></li></ol><h1 id="RGB-与-YUV的转换"><a href="#RGB-与-YUV的转换" class="headerlink" title="RGB 与 YUV的转换"></a>RGB 与 YUV的转换</h1><hr><blockquote><p>参考文献</p><p><a href="https://blog.csdn.net/qq_29575685/article/details/103954096">https://blog.csdn.net/qq_29575685/article/details/103954096</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Camera-Sensor-数据格式&quot;&gt;&lt;a href=&quot;#Camera-Sensor-数据格式&quot; class=&quot;headerlink&quot; title=&quot;Camera Sensor 数据格式&quot;&gt;&lt;/a&gt;Camera Sensor 数据格式&lt;/h1&gt;&lt;hr&gt;
&lt;h2 </summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera 专业知识" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Camera" scheme="https://zh-wiki.github.io/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>自动对焦专讲</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/</id>
    <published>2021-01-21T01:52:02.000Z</published>
    <updated>2021-01-30T08:33:26.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自动对焦的工作原理"><a href="#自动对焦的工作原理" class="headerlink" title="自动对焦的工作原理"></a>自动对焦的工作原理</h1><ul><li>AF的对焦原理是通过电磁感应使镜头移动，改变焦距完成自动对焦。</li></ul><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/image-20201210112852132-1607571037074.png" alt="自动对焦"></p><ul><li><p>VCM 实现对焦原理</p><p>进入自动对焦（AF）模式后，Driver IC输出电流从0到最大值，使得镜头从原始位置移动到最大位置，此时ISP通过sensor成像，计算每一副图片的MTF（Modulation transfer function）值，从而在这条MTF曲线中找到最大值（<strong>即图像最清晰的点</strong>），并通过算法，得到这个点对应的电流大小，再一次指示Driver IC提供给音圈这个电流，而使镜头稳定在这个成像面，达到自动变焦效果。</p><p>AF的目的是确定实现对焦的最佳镜头位置，并触发VCM将镜头移动到该位置。一般来说，AF过程如下：</p><ol><li>AF算法同时检测硬件和软件统计数据，以确定是否存在场景变化。</li><li>如果算法检测到场景变化，则算法触发搜索。</li><li>算法的粗搜索确定下一个镜头位置。</li><li>VCM逐渐将镜头移动到下一个位置。</li><li>精搜索找到最终的镜头位置。</li><li>VCM将镜头移动到最终位置。</li></ol><p>AF对焦方式分为：对比度/反差对焦(CAF)、相位对焦(PDAF)、激光对焦(TOFAF)，每种算法都实现了检测和搜索功能。</p></li></ul><h1 id="反差对焦-CAF"><a href="#反差对焦-CAF" class="headerlink" title="反差对焦  CAF"></a>反差对焦  CAF</h1><p>对比度对焦，也叫反差对焦。反差对焦是目前普及率最高，使用最广泛，成本相对较低的自动对焦技术。对焦的过程就是通过移动镜片来使对焦区域的图像达到最清晰的过程，所以对焦成功以后，直观的感受就是焦点的清晰度最高，而焦点以外的区域则表现为相对模糊状态。因为<strong>反差对焦的工作方式是进行对比度检测</strong>，因此相机镜片必须要前后移动完整记录所有的图像信息，然后计算出对比度最高的位置，才能最终完成对焦，所以反差对焦的一个主要缺点就是耗费的时间较长。</p><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/20200802010227222.png" alt="反差对焦"></p><h1 id="相位差对焦-PDAF"><a href="#相位差对焦-PDAF" class="headerlink" title="相位差对焦 PDAF"></a>相位差对焦 PDAF</h1><h2 id="PDAF-工作原理"><a href="#PDAF-工作原理" class="headerlink" title="PDAF 工作原理"></a>PDAF 工作原理</h2><p>在CMOS（感光元件）上留出一些成对儿的遮蔽像素点来进行相位检测，即从像素传感器上拿出左右相对的成对像素点，分别对场景中的物体进行进光量等信息的检测，通过比对左右两侧的相关值情况，对焦系统根据判断信号波峰的位置可判断出镜头应该往前还是往后偏移，便会迅速找出准确的对焦点，之后镜间马达便会一次性将镜片推动到相应位置完成对焦。位对焦也并不是十分完美，它对光线的要求就比较高，在弱光拍摄环境下，相位对焦就无能为力了。</p><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/image-20201210114809533.png" alt="相位差对焦"></p><p>上图中，紫色是物体的一个点，黄色是sensor即成像面</p><ul><li><p>1号蓝色镜片离sensor太远，上下两条光线所成的像没有重合；</p></li><li><p>2号蓝色镜片和snesor的距离合适，上下两条光线所成的像重合了没有相差，所以对焦成功；</p></li><li><p>3、4号蓝色镜片离sensor的距离太近了，上下两条光线所成的像没有重合，但是和1号不同的是相差的方向是不一样的。</p></li></ul><p>通过<strong>计算相位差并将其转换为defocus(离焦)值</strong>，以指示实现聚焦所需的镜头移动的大小和方向。正defocus值意味着运动由近到远，负defocus值意味着运动从远到近。当defocus值接近零时，表示目标处于焦点。</p><h2 id="PD-值与-lens-位移的转换"><a href="#PD-值与-lens-位移的转换" class="headerlink" title="PD 值与 lens 位移的转换"></a>PD 值与 lens 位移的转换</h2><p>系统在进行对焦的时候，需要将检测到的相位差(phase difference)转换为离焦率(Defocus Value)，这个转换过程应用到的表单数据称为DCC(defocus conversion coefficient)离焦转换系数</p><h1 id="基于camx架构的pdaf-bringup"><a href="#基于camx架构的pdaf-bringup" class="headerlink" title="基于camx架构的pdaf  bringup"></a>基于camx架构的pdaf  bringup</h1><h2 id="pdaf-bringup-需要配置的文件"><a href="#pdaf-bringup-需要配置的文件" class="headerlink" title="pdaf bringup 需要配置的文件"></a>pdaf bringup 需要配置的文件</h2><ol><li><p>pdaf 配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#\vendor\qcom\proprietary\chi-cdk\oem\qcom\sensor\lime_sunny_s5kgm1st_main\xxx_pdaf.xml</span><br><span class="line">#这个pdaf驱动文件由fae提供，相关参数含义如下：</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDAFName</span>&gt;</span>//pdaf名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDOrientation</span>&gt;</span> //pdaf像素方向</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDDefocusConfidenceThreshold</span>&gt;</span> //触发pdaf的阈值，默认200</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDBlackLevel</span>&gt;</span> //黑电平，默认64</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDSensorMode</span>&gt;</span> //对应哪一组sensor setting，配置1对应第2组setting</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDType</span>&gt;</span> //PD类型，datasheet或问FAE</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDNativeBufferFormat</span>&gt;</span> //PD传输格式</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDBlockCountHorizontal</span>&gt;</span> //PD 水平Block的个数，新平台按照16*16分块</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDBlockCountVertical</span>&gt;</span> //PD 垂直Block的个数，新平台按照16*16分块</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDPixelCount</span>&gt;</span> //每个块中PD像素点个数</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDXCoordinate</span>&gt;</span> //第一块中PD像素点的x坐标(绝对坐标，代码中会减去PDOffsetHorizontal)</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDYCoordinate</span>&gt;</span> //第一块中PD像素点的y坐标(绝对坐标，代码中会减去PDOffsetHorizontal)</span><br><span class="line"><span class="tag">&lt;<span class="name">PDBlockDimensions</span>&gt;</span> //每个块宽高，新平台按照16*16分块</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDOffsetHorizontal</span>&gt;</span> //第一块的x偏移量</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDOffsetHorizontal</span>&gt;</span> //第一块的y偏移量</span><br><span class="line"><span class="tag">&lt;<span class="name">PDCropRegion</span>&gt;</span> //sensor full size尺寸</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDDownscaleFactorHorizontal</span>&gt;</span> //当前sensor尺寸的x Downscale</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDDownscaleFactorVertical</span>&gt;</span> //当前sensor尺寸的y Downscale</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDStride</span>&gt;</span> //PDBlockCountHorizontal×每个block中x的pd点个数（l和r）×2</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDBufferFormat</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">PDPixelCount</span>&gt;</span> //第一块PD中的PD点个数</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDXCoordinate</span>&gt;</span> //第一块中PD点x在buffer中的坐标</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDYCoordinate</span>&gt;</span> //第一块中PD点y在buffer中的坐标</span><br><span class="line"><span class="tag">&lt;<span class="name">PDBlockDimensions</span>&gt;</span> //每一块中PD点在buffer的宽高</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDOffsetHorizontal</span>&gt;</span> //每一块中PD点在buffer的x偏移</span><br><span class="line"><span class="tag">&lt;/<span class="name">PDOffsetVertical</span>&gt;</span> //每一块中PD点在buffer的y偏移</span><br></pre></td></tr></table></figure></li><li><p>sensor 配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#### \vendor\qcom\proprietary\chi-cdk\oem\qcom\sensor\lime_sunny_s5kgm1st_main\xxx_sensor.xml</span><br><span class="line">#在对应的sensor setting中添加PD像素配置：</span><br><span class="line"><span class="tag">&lt;<span class="name">streamConfiguration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vc</span> <span class="attr">range</span>=<span class="string">&quot;[0,3]&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">vc</span>&gt;</span>//virtual chennel，查阅datasheet</span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>0x2b<span class="tag">&lt;/<span class="name">dt</span>&gt;</span>//mipi data type，setting说明中</span><br><span class="line"><span class="tag">&lt;<span class="name">frameDimension</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xStart</span>&gt;</span>0<span class="tag">&lt;/<span class="name">xStart</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">yStart</span>&gt;</span>0<span class="tag">&lt;/<span class="name">yStart</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">width</span>&gt;</span>992<span class="tag">&lt;/<span class="name">width</span>&gt;</span>//x方向的PD点个数</span><br><span class="line"><span class="tag">&lt;<span class="name">height</span>&gt;</span>748<span class="tag">&lt;/<span class="name">height</span>&gt;</span>//y方向的PD点个数</span><br><span class="line"><span class="tag">&lt;/<span class="name">frameDimension</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bitWidth</span>&gt;</span>10<span class="tag">&lt;/<span class="name">bitWidth</span>&gt;</span>//位宽</span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>PDAF<span class="tag">&lt;/<span class="name">type</span>&gt;</span>//类型</span><br><span class="line"><span class="tag">&lt;/<span class="name">streamConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#注意：此配置只有在pdaf类型为type2的时候需要，type3类型的pd无需在sensor xml中配置</span><br></pre></td></tr></table></figure></li><li><p>module 配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#\vendor\qcom\proprietary\chi-cdk\oem\qcom\module\xxx_module.xml</span><br><span class="line"><span class="tag">&lt;/<span class="name">pdafName</span>&gt;</span>//pdaf name,与xxx_pdaf.xml中的一致</span><br></pre></td></tr></table></figure></li><li><p>yaml 配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#\vendor\qcom\proprietary\chi-cdk\tools\buildbins\xxx.yaml</span></span><br><span class="line"><span class="attr">sensor_drivers:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">com.qti.sensormodule.lime_sunny_s5kgm1st_main:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">sensor/lime_sunny_s5kgm1st_main/lime_sunny_s5kgm1st_main_pdaf.xml</span></span><br></pre></td></tr></table></figure></li><li><p>平台配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#vendor/qcom/proprietary/camx/src/settings/common/camxsettings.xml </span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span>&gt;</span>is_stable=TRUE</span><br><span class="line">Line 1001836: 01-03 07:11:53.503   681  4760 D mm-camera</span><br><span class="line"><span class="tag">&lt;<span class="name">Name</span>&gt;</span>Disable PDAF<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">Help</span>&gt;</span>Completely disable PDAF<span class="tag">&lt;/<span class="name">Help</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>disablePDAF<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VariableType</span>&gt;</span>BOOL<span class="tag">&lt;/<span class="name">VariableType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SetpropKey</span>&gt;</span>persist.vendor.camera.disablePDAF<span class="tag">&lt;/<span class="name">SetpropKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DefaultValue</span>&gt;</span>FALSE<span class="tag">&lt;/<span class="name">DefaultValue</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Dynamic</span>&gt;</span>TRUE<span class="tag">&lt;/<span class="name">Dynamic</span>&gt;</span></span><br></pre></td></tr></table></figure><p>check persist.vendor.camera.disablePDAF是否为false;如果为true，则需 <strong>adb shell setprop  persist.vendor.camera.disablePDAF FALSE</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#vendor/qcom/proprietary/chi-cdk/oem/qcom/tuning/lime_sunny_s5kgm1st_main_c7project/Scenario.Default/XML/STATS/chromatixHAF.xml </span><br><span class="line">  check下</span><br><span class="line">  <span class="tag">&lt;<span class="name">PDAFEnable</span>&gt;</span>1<span class="tag">&lt;/<span class="name">PDAFEnable</span>&gt;</span>这一项要置1</span><br></pre></td></tr></table></figure></li></ol><h2 id="pdaf-debug"><a href="#pdaf-debug" class="headerlink" title="pdaf debug"></a>pdaf debug</h2><p>更新xxx_sensor.bin文件后，打开debug log:</p><p>adb shell “echo afFullsweep=3&gt;&gt; /vendor/etc/camera/camxoverridesettings.txt”<br>adb shell “echo logVerboseMask=0x8000202 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt”<br>adb shell “echo logInfoMask=0x8000202 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt”</p><p>重启后打开摄像头，焦距范围内对着黑白条纹纸张拍摄，此时AF会跑Fullsweep的代码，检索关键字</p><p>adb logcat | grep “af_pdaf_proc_pd_single roi(0) lens_pos”  &gt; fullsweep.txt</p><p>其中lens_pos增大时，defocus(um)减小；lens_pos减小时，defocus(um)增大，且相加几乎是一个恒定值。而且conf的数值在1023左右。选择lens_pos 和pd两项数值做成折线图 </p><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/%E8%87%AA%E5%8A%A8%E5%AF%B9%E7%84%A6/image-20201214170737637.png" alt="线形图"></p><p>能清晰的看到lens_pos 和pd是成线性关系的，且能看到pd =0是有相应的len_pos值，则pdaf应该就没什么问题了</p><h1 id="高通MM架构-PDAF-调试方法"><a href="#高通MM架构-PDAF-调试方法" class="headerlink" title="高通MM架构 PDAF 调试方法"></a>高通MM架构 PDAF 调试方法</h1><ol><li><p>首先设置号相应的log权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell setprop persist.camera.stats.af.debug 5</span><br><span class="line">adb shell setprop persist.camera.stats.haf.debug 5</span><br></pre></td></tr></table></figure></li><li><p>使相机进入fullsweep(全扫描)模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell setprop vendor.debug.camera.af_fullsweep 1</span><br></pre></td></tr></table></figure><p>可能不同的平台命令有所不同，可以在代码中搜索</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/stats/q3a/af/af_biz.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">af_biz_process</span><span class="params">(<span class="keyword">stats_af_t</span> *stats, <span class="keyword">af_output_data_t</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">uint8_t</span> num_of_outputs, <span class="keyword">void</span> *af_obj)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="comment">// Get Setproc for fullsweep algo.</span></span><br><span class="line">   <span class="comment">/* Enable full-sweep property:</span></span><br><span class="line"><span class="comment">     * 0 - disable</span></span><br><span class="line"><span class="comment">     * 1 - far-to-near</span></span><br><span class="line"><span class="comment">     * 2 - reverse search (near-to-far)</span></span><br><span class="line"><span class="comment">     * 3 - both (far-&gt;near-&gt;far)*/</span></span><br><span class="line">    property_get(<span class="string">&quot;vendor.debug.camera.af_fullsweep&quot;</span>, value, <span class="string">&quot;0&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>log 分析</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Line <span class="number">86657</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">00</span><span class="variable">.426</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">438</span> index=<span class="number">14</span>, pd=-<span class="number">10</span><span class="variable">.02</span>, defocus(um)=-<span class="number">248</span>, conf=<span class="number">537</span>, is_conf=FALSE, not_conf_cnt=<span class="number">13</span>, is_stable=TRUE</span><br><span class="line">Line <span class="number">88565</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">00</span><span class="variable">.504</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">438</span> index=<span class="number">16</span>, pd=-<span class="number">10</span><span class="variable">.24</span>, defocus(um)=-<span class="number">253</span>, conf=<span class="number">559</span>, is_conf=FALSE, not_conf_cnt=<span class="number">15</span>, is_stable=TRUE</span><br><span class="line">Line <span class="number">94865</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">00</span><span class="variable">.769</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">434</span> index=<span class="number">22</span>, pd=-<span class="number">10</span><span class="variable">.55</span>, defocus(um)=-<span class="number">262</span>, conf=<span class="number">532</span>, is_conf=FALSE, not_conf_cnt=<span class="number">21</span>, is_stable=TRUE</span><br><span class="line">Line <span class="number">98620</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">00</span><span class="variable">.905</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">432</span> index=<span class="number">26</span>, pd=-<span class="number">10</span><span class="variable">.45</span>, defocus(um)=-<span class="number">259</span>, conf=<span class="number">547</span>, is_conf=FALSE, not_conf_cnt=<span class="number">25</span>, is_stable=TRUE</span><br><span class="line">..................</span><br><span class="line">Line <span class="number">692125</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">35</span><span class="variable">.301</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">4</span> index=<span class="number">34</span>, pd=<span class="number">6</span><span class="variable">.69</span>, defocus(um)=<span class="number">166</span>, conf=<span class="number">916</span>, is_conf=FALSE, not_conf_cnt=<span class="number">259</span>, is_stable=TRUE</span><br><span class="line">Line <span class="number">694909</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">35</span><span class="variable">.424</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">2</span> index=<span class="number">37</span>, pd=<span class="number">6</span><span class="variable">.72</span>, defocus(um)=<span class="number">166</span>, conf=<span class="number">917</span>, is_conf=FALSE, not_conf_cnt=<span class="number">262</span>, is_stable=TRUE</span><br><span class="line">Line <span class="number">697981</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">35</span><span class="variable">.661</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">0</span> index=<span class="number">43</span>, pd=<span class="number">6</span><span class="variable">.83</span>, defocus(um)=<span class="number">169</span>, conf=<span class="number">945</span>, is_conf=FALSE, not_conf_cnt=<span class="number">268</span>, is_stable=TRUE</span><br><span class="line">.................</span><br><span class="line">Line <span class="number">1000442</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">53</span><span class="variable">.425</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">166</span> index=<span class="number">36</span>, pd=-<span class="number">0</span><span class="variable">.06</span>, defocus(um)=-<span class="number">1</span>, conf=<span class="number">705</span>, is_conf=TRUE, not_conf_cnt=<span class="number">0</span>, is_stable=TRUE</span><br><span class="line">Line <span class="number">1001078</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">53</span><span class="variable">.460</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">166</span> index=<span class="number">37</span>, pd=<span class="number">0</span><span class="variable">.05</span>, defocus(um)=<span class="number">1</span>, conf=<span class="number">695</span>, is_conf=TRUE, not_conf_cnt=<span class="number">0</span>, is_stable=TRUE</span><br><span class="line">Line <span class="number">1001836</span>: <span class="number">01</span>-<span class="number">03</span> <span class="number">07</span>:<span class="number">11</span>:<span class="number">53</span><span class="variable">.503</span>   <span class="number">681</span>  <span class="number">4760</span> D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; <span class="number">3586</span>: af_pdaf_proc_pd_single: roi(<span class="number">0</span>) lens_pos=<span class="number">166</span> index=<span class="number">38</span>, pd=<span class="number">0</span><span class="variable">.15</span>, defocus(um)=<span class="number">3</span>, conf=<span class="number">731</span>, is_conf=TRUE, not_conf_cnt=<span class="number">0</span>, is_stable=TRUE</span><br></pre></td></tr></table></figure><p>进入fullsweep Mode Far to Near</p><ul><li><p>进行完一次全扫描后，lens position 最终是 166，观察pd值 和 defocus 接近于0 表示正常</p></li><li><p>过程中观察 pd 和 defocus 值应该是成线性的 </p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自动对焦的工作原理&quot;&gt;&lt;a href=&quot;#自动对焦的工作原理&quot; class=&quot;headerlink&quot; title=&quot;自动对焦的工作原理&quot;&gt;&lt;/a&gt;自动对焦的工作原理&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;AF的对焦原理是通过电磁感应使镜头移动，改变焦距完成自动对焦。&lt;/li&gt;</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera 专业知识" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Camera" scheme="https://zh-wiki.github.io/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>Camera 成像原理和专业知识</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/Camera%20%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E5%92%8C%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/Camera%20%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E5%92%8C%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/</id>
    <published>2021-01-21T01:52:01.000Z</published>
    <updated>2021-01-30T08:33:17.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Camera-模组"><a href="#Camera-模组" class="headerlink" title="Camera 模组"></a>Camera 模组</h1><hr><ol><li><p>基本介绍</p><ul><li><p>一个camera主要由两部分组成，镜头(Lens)，感光IC(Sensor IC)。其中大部分的Sensor都是自己集成DSP的。</p></li><li><p>Sensor将Lens上传导过来的光线转换为电信号，通过CFA滤波后，变为三基色，再通过内部的DA转换为数字信号。对于CFA模式的相机来说，Sensor中的每个pixel只能感光R光/B光/G光，因此每个像素此时存贮的都是单色的。</p></li><li><p>一个camera的输出信号：</p><p>一般有data信号，输出YUV，RGB，JPEG格式的数据。</p><p>hsync信号，行同步信号，表示一个frame有效。</p><p>vsync信号，列同步信号，对于一个frame表示新的一行有效。</p><p>PCLK信号，每一个像素的同步时钟。</p><p>输出I2C总线，主要用在通信，寄存器配置。</p></li></ul></li></ol><h1 id="彩色滤波阵列-CFA"><a href="#彩色滤波阵列-CFA" class="headerlink" title="彩色滤波阵列-CFA"></a>彩色滤波阵列-CFA</h1><hr><p>图像传感器都采用一定的模式来采集图像数据，常用的有 RGB 模式和 CFA 模式。BGR 模式是一种可直接进行显示和压缩等处理的图像数据模式，它由 R( 红)、G( 绿) 、B( 蓝) 三原色值来共同确定 1 个像素点，例如富士数码相机采用的 SUPER CCD 图像传感器就采用这种模式，其优点是图像传感器产生的图像数据无需插值就可直接进行显示等后续处理，图像效果最好，但是成本高，常用于专业相机中。</p><p>为了减少成本，缩小体积，市场上的数码相机大多采用 CFA 模式，即在像素阵列的表面覆盖一层彩色滤波阵列（Color Filter Array，CFA），彩色滤波阵列有多种，现在应用最广泛的是 Bayer 格式滤波阵列，满足 GRBG 规律，绿色像素数是红色或蓝色像素数的两倍，这是因为人眼对可见光光谱敏感度的峰值位于中波段，这正好对应着绿色光谱成分。在该模式下图像数据只用R, G, B三个值中的一个值来表示一个像素点，而缺失另外两个颜色值，这时得到的是一副马赛克图片，为了得到全彩色的图像，需要使用其周围像素点的色彩信息来估计缺失的另外两种颜色，这种处理叫做色彩插值。</p><h1 id="相位对焦-PDAF-Phase-Detection-Auto-Focus"><a href="#相位对焦-PDAF-Phase-Detection-Auto-Focus" class="headerlink" title="相位对焦 PDAF (Phase Detection Auto Focus)"></a>相位对焦 PDAF (Phase Detection Auto Focus)</h1><hr><ol><li><p><strong>简介</strong></p><p>在CMOS（感光元件）上留出一些成对儿的遮蔽像素点来进行相位检测，即从像素传感器上拿出左右相对的成对像素点，分别对场景中的物体进行进光量等信息的检测，通过比对左右两侧的相关值情况，对焦系统根据判断信号波峰的位置可判断出镜头应该往前还是往后偏移，便会迅速找出准确的对焦点，之后镜间马达便会一次性将镜片推动到相应位置完成对焦。</p></li><li><p><strong>对焦的基本过程</strong></p><ul><li>通过左右(屏蔽像素点)shield pixel之间的差异来将被摄物映射到镜头移动距离中的某个位置。</li><li>系统在进行对焦的时候，需要将检测到的相位差(phase difference)转换为离焦率(Defocus Value)，这个转换过程应用到的表单数据称为DCC(defocus conversion coefficient)离焦转换系数。</li></ul></li></ol><h1 id="Camera-尺寸相关"><a href="#Camera-尺寸相关" class="headerlink" title="Camera 尺寸相关"></a>Camera 尺寸相关</h1><hr><p>我们在追Camera configureStream 流程的时候一般会看到以下关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HAL_PIXEL_FORMAT_BLOB = <span class="number">33</span>;</span><br><span class="line">HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED = <span class="number">34</span>;</span><br><span class="line">HAL_PIXEL_FORMAT_YCbCr_420_888 = <span class="number">35</span>;</span><br></pre></td></tr></table></figure><ul><li>HAL_PIXEL_FORMAT_BLOB表示是jpeg stream，对应的size即平时所说的picture size</li><li>HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED表示preview stream，对应的size即平时所说的preview size.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Camera-模组&quot;&gt;&lt;a href=&quot;#Camera-模组&quot; class=&quot;headerlink&quot; title=&quot;Camera 模组&quot;&gt;&lt;/a&gt;Camera 模组&lt;/h1&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基本介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个camer</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera 专业知识" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Camera" scheme="https://zh-wiki.github.io/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>camera 基础知识</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/camea%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/camea%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-01-21T01:52:00.000Z</published>
    <updated>2021-01-30T08:33:17.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CMOS-Sensor-简介"><a href="#CMOS-Sensor-简介" class="headerlink" title="CMOS Sensor 简介"></a>CMOS Sensor 简介</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="01_cmos_sensor.mp4" type="video/mp4"></video><h1 id="Color-Science"><a href="#Color-Science" class="headerlink" title="Color Science"></a>Color Science</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="02_color_science.mp4" type="video/mp4"></video><h1 id="光学基础"><a href="#光学基础" class="headerlink" title="光学基础"></a>光学基础</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="03_光学基础.mp4" type="video/mp4"></video><h1 id="图像信号处理"><a href="#图像信号处理" class="headerlink" title="图像信号处理"></a>图像信号处理</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="04_图像信号处理.mp4" type="video/mp4"></video><h1 id="3A系统概述"><a href="#3A系统概述" class="headerlink" title="3A系统概述"></a>3A系统概述</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="05_3A系统概述.mp4" type="video/mp4"></video><h1 id="黑电平与线性化"><a href="#黑电平与线性化" class="headerlink" title="黑电平与线性化"></a>黑电平与线性化</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="06_黑电平与线性化.mp4" type="video/mp4"></video><h1 id="Green-Imbalence"><a href="#Green-Imbalence" class="headerlink" title="Green Imbalence"></a>Green Imbalence</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="07_GreenImbalence.mp4" type="video/mp4"></video><h1 id="坏点消除"><a href="#坏点消除" class="headerlink" title="坏点消除"></a>坏点消除</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="08_坏点消除.mp4" type="video/mp4"></video><h1 id="Lens-Shading"><a href="#Lens-Shading" class="headerlink" title="Lens Shading"></a>Lens Shading</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="09_lens_shading.mp4" type="video/mp4"></video><h1 id="Raw-Denosie"><a href="#Raw-Denosie" class="headerlink" title="Raw Denosie"></a>Raw Denosie</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="10_raw_denosie.mp4" type="video/mp4"></video><h1 id="Dynamic-Range-And-Tone"><a href="#Dynamic-Range-And-Tone" class="headerlink" title="Dynamic Range And Tone"></a>Dynamic Range And Tone</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="11_dynamic_range_and_tone.mp4" type="video/mp4"></video><h1 id="Demosaic"><a href="#Demosaic" class="headerlink" title="Demosaic"></a>Demosaic</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="12_Demosaic.mp4" type="video/mp4"></video><h1 id="Color-Reporoduciton"><a href="#Color-Reporoduciton" class="headerlink" title="Color Reporoduciton"></a>Color Reporoduciton</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="13_color_reporoduciton.mp4" type="video/mp4"></video><h1 id="Color-Correction"><a href="#Color-Correction" class="headerlink" title="Color Correction"></a>Color Correction</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="14_color_correction.mp4" type="video/mp4"></video><h1 id="Gamma与对比度增强"><a href="#Gamma与对比度增强" class="headerlink" title="Gamma与对比度增强"></a>Gamma与对比度增强</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="15_Gamma与对比度增强.mp4" type="video/mp4"></video><h1 id="Sharpening"><a href="#Sharpening" class="headerlink" title="Sharpening"></a>Sharpening</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="16_Sharpening.mp4" type="video/mp4"></video><h1 id="Color-Space-Matrix"><a href="#Color-Space-Matrix" class="headerlink" title="Color Space Matrix"></a>Color Space Matrix</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="17_Color_Space_Matrix.mp4" type="video/mp4"></video><h1 id="Spatial-Denoise"><a href="#Spatial-Denoise" class="headerlink" title="Spatial Denoise"></a>Spatial Denoise</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="18_spatial_denoise.mp4" type="video/mp4"></video><h1 id="Temor"><a href="#Temor" class="headerlink" title="Temor"></a>Temor</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="19_temor.mp4" type="video/mp4"></video><h1 id="Depurple"><a href="#Depurple" class="headerlink" title="Depurple"></a>Depurple</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="20_depurple.mp4" type="video/mp4"></video><h1 id="ISP-统计信息"><a href="#ISP-统计信息" class="headerlink" title="ISP 统计信息"></a>ISP 统计信息</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="21_isp统计信息.mp4" type="video/mp4"></video><h1 id="自动曝光"><a href="#自动曝光" class="headerlink" title="自动曝光"></a>自动曝光</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="22_自动曝光.mp4" type="video/mp4"></video><h1 id="自动白平衡"><a href="#自动白平衡" class="headerlink" title="自动白平衡"></a>自动白平衡</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="23_自动白平衡.mp4" type="video/mp4"></video><h1 id="自动对焦"><a href="#自动对焦" class="headerlink" title="自动对焦"></a>自动对焦</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="24_自动对焦.mp4" type="video/mp4"></video><h1 id="闪光灯"><a href="#闪光灯" class="headerlink" title="闪光灯"></a>闪光灯</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="25_闪光灯.mp4" type="video/mp4"></video><h1 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="26_HDR.mp4" type="video/mp4"></video><h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="27_文件格式.mp4" type="video/mp4"></video><h1 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h1><hr><h2 id="上集"><a href="#上集" class="headerlink" title="上集"></a>上集</h2><video id="video" controls preload="none">    <source id="mp4" src="28_encoder1.mp4" type="video/mp4"></video><h2 id="下集"><a href="#下集" class="headerlink" title="下集"></a>下集</h2><video id="video" controls preload="none">    <source id="mp4" src="29_encoder2.mp4" type="video/mp4"></video><h1 id="图像防抖"><a href="#图像防抖" class="headerlink" title="图像防抖"></a>图像防抖</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="30_图像防抖.mp4" type="video/mp4"></video><h1 id="图像质量评价工具与方法"><a href="#图像质量评价工具与方法" class="headerlink" title="图像质量评价工具与方法"></a>图像质量评价工具与方法</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="31_图像质量评价工具与方法.mp4" type="video/mp4"></video><h1 id="画质调优"><a href="#画质调优" class="headerlink" title="画质调优"></a>画质调优</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="32_画质调优.mp4" type="video/mp4"></video><h1 id="双摄及景深计算"><a href="#双摄及景深计算" class="headerlink" title="双摄及景深计算"></a>双摄及景深计算</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="33_双摄及景深计算.mp4" type="video/mp4"></video><h1 id="成像系统仿真"><a href="#成像系统仿真" class="headerlink" title="成像系统仿真"></a>成像系统仿真</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="34_成像系统仿真.mp4" type="video/mp4"></video><h1 id="结构光"><a href="#结构光" class="headerlink" title="结构光"></a>结构光</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="35_结构光.mp4" type="video/mp4"></video><h1 id="TOF-概述"><a href="#TOF-概述" class="headerlink" title="TOF 概述"></a>TOF 概述</h1><hr><video id="video" controls preload="none">    <source id="mp4" src="36_TOF概述.mp4" type="video/mp4"></video>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CMOS-Sensor-简介&quot;&gt;&lt;a href=&quot;#CMOS-Sensor-简介&quot; class=&quot;headerlink&quot; title=&quot;CMOS Sensor 简介&quot;&gt;&lt;/a&gt;CMOS Sensor 简介&lt;/h1&gt;&lt;hr&gt;
&lt;video id=&quot;video&quot; co</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera 专业知识" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="camera基础知识" scheme="https://zh-wiki.github.io/tags/camera%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>ITS 测试案例分析</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/XTS%20%E7%9B%B8%E5%85%B3/ITS%20%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/XTS%20%E7%9B%B8%E5%85%B3/ITS%20%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</id>
    <published>2020-12-31T16:00:01.000Z</published>
    <updated>2021-01-30T08:33:26.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scene1-2-test-yuv-plus-raw10-py"><a href="#scene1-2-test-yuv-plus-raw10-py" class="headerlink" title="scene1_2 test_yuv_plus_raw10.py"></a>scene1_2 test_yuv_plus_raw10.py</h1><hr><h2 id="该case主要是测试什么？"><a href="#该case主要是测试什么？" class="headerlink" title="该case主要是测试什么？"></a>该case主要是测试什么？</h2><ul><li>通过测试脚本应该是测试</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;scene1-2-test-yuv-plus-raw10-py&quot;&gt;&lt;a href=&quot;#scene1-2-test-yuv-plus-raw10-py&quot; class=&quot;headerlink&quot; title=&quot;scene1_2 test_yuv_plus_raw10.p</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="XTS 相关" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/XTS-%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="XTS" scheme="https://zh-wiki.github.io/tags/XTS/"/>
    
  </entry>
  
  <entry>
    <title>生活学习</title>
    <link href="https://zh-wiki.github.io/undefined/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zh-wiki.github.io/undefined/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-10-04T08:22:36.000Z</published>
    <updated>2021-01-30T08:33:26.279Z</updated>
    
    
    
    
    <category term="生活学习" scheme="https://zh-wiki.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>艺术</title>
    <link href="https://zh-wiki.github.io/undefined/%E8%89%BA%E6%9C%AF/%E8%89%BA%E6%9C%AF/"/>
    <id>https://zh-wiki.github.io/undefined/%E8%89%BA%E6%9C%AF/%E8%89%BA%E6%9C%AF/</id>
    <published>2020-10-04T08:22:36.000Z</published>
    <updated>2021-01-30T08:33:26.279Z</updated>
    
    
    
    
    <category term="艺术" scheme="https://zh-wiki.github.io/categories/%E8%89%BA%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>UML</title>
    <link href="https://zh-wiki.github.io/undefined/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/UML/"/>
    <id>https://zh-wiki.github.io/undefined/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/UML/</id>
    <published>2020-09-29T15:23:24.000Z</published>
    <updated>2021-01-30T08:33:26.279Z</updated>
    
    
    
    
    <category term="程序语言" scheme="https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"/>
    
    <category term="UML" scheme="https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/"/>
    
    
    <category term="UML" scheme="https://zh-wiki.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx Bring up</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/</id>
    <published>2019-12-31T16:00:30.000Z</published>
    <updated>2021-01-30T08:33:17.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bring-Up-Sensor"><a href="#Bring-Up-Sensor" class="headerlink" title="Bring Up Sensor"></a>Bring Up Sensor</h1><h2 id="HAL层的配置"><a href="#HAL层的配置" class="headerlink" title="HAL层的配置"></a>HAL层的配置</h2><ol><li><p>移植驱动代码到相应的路径</p><p>vendor/qcom/proprietary/chi-cdk/oem/qcom/sensor/</p><p>驱动文件名字根据项目而定</p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/image-20201111142550122.png" alt="驱动代码" style="zoom:200%;"></li><li><p>sensor xml 相关配置</p><details><summary>lime_sunny_hi259_macro_sensor.xml</summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slaveInfo</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Name of the sensor --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sensorName</span>&gt;</span>lime_sunny_hi259_macro<span class="tag">&lt;/<span class="name">sensorName</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--8-bit or 10-bit write slave address</span></span><br><span class="line"><span class="comment">       For External Sensors for which camx needs not probe the slave address shoule be as 0 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">slaveAddress</span>&gt;</span>0x60<span class="tag">&lt;/<span class="name">slaveAddress</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Register address / data size in bytes --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">regAddrType</span> <span class="attr">range</span>=<span class="string">&quot;[1,4]&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">regAddrType</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Register address / data size in bytes --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">regDataType</span> <span class="attr">range</span>=<span class="string">&quot;[1,4]&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">regDataType</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Register address for sensor Id --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sensorIdRegAddr</span>&gt;</span>0x04<span class="tag">&lt;/<span class="name">sensorIdRegAddr</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Sensor Id 0xE1--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sensorId</span>&gt;</span>0x113<span class="tag">&lt;/<span class="name">sensorId</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Mask for sensor id. Sensor Id may only be few bits --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">sensorIdMask</span>&gt;</span>4294967295<span class="tag">&lt;/<span class="name">sensorIdMask</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--I2C frequency mode of slave</span></span><br><span class="line"><span class="comment">       Supported modes are: STANDARD (100 KHz), FAST (400 KHz), FAST_PLUS (1 MHz), CUSTOM (Custom frequency in DTSI) --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">i2cFrequencyMode</span>&gt;</span>FAST<span class="tag">&lt;/<span class="name">i2cFrequencyMode</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Sequence of power configuration type and configuration value required to control power to the device --&gt;</span></span><br><span class="line">   </span><br><span class="line">  <span class="tag">&lt;<span class="name">powerUpSequence</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>RESET<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>1<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>CUSTOM_GPIO1<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>0<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>CUSTOM_GPIO2<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>2<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>MCLK<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>24000000<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>8<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>RESET<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>1<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">powerUpSequence</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Sequence of power configuration type and configuration value required to control power to the device --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">powerDownSequence</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--Power setting configuration</span></span><br><span class="line"><span class="comment">         Contains: configType, configValue and delay in milli seconds --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">configType</span>&gt;</span>RESET<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>1<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>1<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>MCLK<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>0<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>CUSTOM_GPIO1<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>0<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configType</span>&gt;</span>CUSTOM_GPIO2<span class="tag">&lt;/<span class="name">configType</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">configValue</span>&gt;</span>0<span class="tag">&lt;/<span class="name">configValue</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">delayMs</span>&gt;</span>1<span class="tag">&lt;/<span class="name">delayMs</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">powerSetting</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">powerDownSequence</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">slaveInfo</span>&gt;</span></span><br></pre></td></tr></table></figure></details><ul><li>sensor name 跟sensor  文件夹名字一致</li><li>slaveAddress IIC 从机地址</li><li>sensor id 寄存器地址 以及 sensor id</li><li>上下电时序 (为了保险首先将reset引脚设置为禁止状态)</li></ul></li><li><p>module xml 配置</p><details><summary>lime_sunny_hi259_macro_module.xml</summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--========================================================================--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Copyright (c) 2018 Qualcomm Technologies, Inc.                         --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- All Rights Reserved.                                                   --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Confidential and Proprietary - Qualcomm Technologies, Inc.             --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--========================================================================--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cameraModuleData</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;..\..\..\api\sensor\camxmoduleconfig.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module_version</span> <span class="attr">major_revision</span>=<span class="string">&quot;1&quot;</span> <span class="attr">minor_revision</span>=<span class="string">&quot;0&quot;</span> <span class="attr">incr_revision</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Module group can contain either 1 module or 2 modules</span></span><br><span class="line"><span class="comment">      Dual camera, stereo camera use cases contain 2 modules in the group --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">moduleGroup</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Module configuration --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">moduleConfiguration</span> <span class="attr">description</span>=<span class="string">&quot;Module configuration&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--CameraId is the id to which DTSI node is mapped.</span></span><br><span class="line"><span class="comment">          Typically CameraId is the slot Id for non combo mode. --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">cameraId</span>&gt;</span>3<span class="tag">&lt;/<span class="name">cameraId</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Name of the module integrator --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">moduleName</span>&gt;</span>sunny<span class="tag">&lt;/<span class="name">moduleName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Name of the sensor in the image sensor module --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">sensorName</span>&gt;</span>lime_sunny_hi259_macro<span class="tag">&lt;/<span class="name">sensorName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Actuator name in the image sensor module</span></span><br><span class="line"><span class="comment">          This is an optional element. Skip this element if actuator is not present --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">actuatorName</span>&gt;</span><span class="tag">&lt;/<span class="name">actuatorName</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">oisName</span>&gt;</span><span class="tag">&lt;/<span class="name">oisName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--EEPROM name in the image sensor module</span></span><br><span class="line"><span class="comment">          This is an optional element. Skip this element if EEPROM is not present --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">eepromName</span>&gt;</span><span class="tag">&lt;/<span class="name">eepromName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Flash name is used to used to open binary.</span></span><br><span class="line"><span class="comment">          Binary name is of form flashName_flash.bin Ex:- pmic_flash.bin --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">flashName</span>&gt;</span><span class="tag">&lt;/<span class="name">flashName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Chromatix name is used to used to open binary.</span></span><br><span class="line"><span class="comment">          Binary name is of the form sensor_model_chromatix.bin --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">chromatixName</span>&gt;</span>lime_sunny_hi259_macro<span class="tag">&lt;/<span class="name">chromatixName</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Position of the sensor module.</span></span><br><span class="line"><span class="comment">          Valid values are: REAR, FRONT, REAR_AUX, FRONT_AUX, EXTERNAL --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">position</span>&gt;</span>REAR_AUX<span class="tag">&lt;/<span class="name">position</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--CSI Information --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CSIInfo</span> <span class="attr">description</span>=<span class="string">&quot;CSI Information&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">laneAssign</span>&gt;</span>2<span class="tag">&lt;/<span class="name">laneAssign</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">isComboMode</span>&gt;</span>1<span class="tag">&lt;/<span class="name">isComboMode</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">CSIInfo</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--Lens information --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">lensInfo</span> <span class="attr">description</span>=<span class="string">&quot;Lens Information&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Focal length of the lens in millimeters. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">focalLength</span>&gt;</span>4.71<span class="tag">&lt;/<span class="name">focalLength</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--F-Number of the optical system. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fNumber</span>&gt;</span>1.79<span class="tag">&lt;/<span class="name">fNumber</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Minimum focus distance in meters. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">minFocusDistance</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">minFocusDistance</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Total focus distance in meters. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxFocusDistance</span>&gt;</span>1.9<span class="tag">&lt;/<span class="name">maxFocusDistance</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Horizontal view angle in degrees. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">horizontalViewAngle</span>&gt;</span>67<span class="tag">&lt;/<span class="name">horizontalViewAngle</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Vertical view angle in degrees. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">verticalViewAngle</span>&gt;</span>53<span class="tag">&lt;/<span class="name">verticalViewAngle</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Maximum Roll Degree. Valid values are: 0, 90, 180, 270, 360 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxRollDegree</span>&gt;</span>270<span class="tag">&lt;/<span class="name">maxRollDegree</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Maximum Pitch Degree. Valid values are: 0 to 359 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxPitchDegree</span>&gt;</span>360<span class="tag">&lt;/<span class="name">maxPitchDegree</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Maximum Yaw Degree. Valid values are: 0 to 359 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxYawDegree</span>&gt;</span>360<span class="tag">&lt;/<span class="name">maxYawDegree</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">lensInfo</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pdafName</span>&gt;</span><span class="tag">&lt;/<span class="name">pdafName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">moduleConfiguration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">moduleGroup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cameraModuleData</span>&gt;</span></span><br></pre></td></tr></table></figure></details><ul><li>配置 CameraId 与kernel dts 相对应</li><li>配置sensorname 与 sensor xml 保持一致</li><li>配置 chromatixName 与 sensor name 保持一致</li><li>配置 position 摄像头位置 前摄 后摄 或者 后辅</li><li>配置 CSIInfo mipi 通道</li></ul></li></ol><h1 id="双摄帧同步导通"><a href="#双摄帧同步导通" class="headerlink" title="双摄帧同步导通"></a>双摄帧同步导通</h1><ol><li><p>将camx平台默认的几个属性开启</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> //camxsettings.xml      </span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>multiCameraEnable<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>multiCameraHWSyncMask<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>multiCameraFrameSyncMask<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">VariableName</span>&gt;</span>multiCameraFPSMatchMask<span class="tag">&lt;/<span class="name">VariableName</span>&gt;</span></span><br><span class="line">//高通的case还给了这两个，j19S项目代码中没有找到这连个配置，没有配置也是OK的</span><br><span class="line">adb shell &quot;echo multiCamera3ASync=QTI &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot;</span><br><span class="line">adb shell &quot;echo multiCameraSATEnable=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot;</span><br></pre></td></tr></table></figure></li><li><p>在Camera Id 映射的位置指定双摄的Camera Id</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> LogicalCameraConfiguration logicalCameraConfigurationKamorta[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*cameraId cameraType              exposeFlag phyDevCnt  sensorId, transition low, high, smoothZoom, alwaysOn  realtimeEngine            primarySensorID, hwMaster*/</span></span><br><span class="line">    &#123;<span class="number">0</span>,        LogicalCameraType_Default, TRUE,      <span class="number">1</span>,    &#123;&#123;<span class="number">0</span>,                    <span class="number">0.0</span>, <span class="number">0.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">0</span>,              <span class="number">0</span>    &#125;, <span class="comment">///&lt; Wide camera</span></span><br><span class="line">    &#123;<span class="number">1</span>,        LogicalCameraType_Default, TRUE,      <span class="number">1</span>,    &#123;&#123;<span class="number">2</span>,                    <span class="number">0.0</span>, <span class="number">0.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">2</span>,              <span class="number">2</span>    &#125;, <span class="comment">///&lt; Front camera</span></span><br><span class="line">    &#123;<span class="number">2</span>,        LogicalCameraType_Default, TRUE,      <span class="number">1</span>,    &#123;&#123;<span class="number">1</span>,                    <span class="number">0.0</span>, <span class="number">0.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">1</span>,              <span class="number">1</span>    &#125;, <span class="comment">///&lt; Tele camera</span></span><br><span class="line">    &#123;<span class="number">3</span>,        LogicalCameraType_Default, TRUE,      <span class="number">1</span>,    &#123;&#123;<span class="number">3</span>,                    <span class="number">0.0</span>, <span class="number">0.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">3</span>,              <span class="number">3</span>    &#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,        LogicalCameraType_RTB,     TRUE,      <span class="number">2</span>,    &#123;&#123;<span class="number">0</span>,                    <span class="number">2.0</span>, <span class="number">8.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;,</span><br><span class="line">                                                            &#123;<span class="number">2</span>,                    <span class="number">1.0</span>, <span class="number">2.0</span>,   FALSE,    TRUE,     RealtimeEngineType_IFE&#125;&#125;,  <span class="number">0</span>,              <span class="number">0</span>    &#125;, <span class="comment">///&lt; RTB</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在j19S项目中更改了一下参数 。（双摄预览出图是辐摄）</p><ul><li>第一个参数: 调节zoom值</li><li>第二个参数: 配置主摄的camera Id</li></ul><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20Bring%20up/image-20201112172851742.png" alt="双摄帧同步"></p><p>在j19S项目中还有存在一个平台bug （上面介绍的结构体双摄不能为最后一个成员）</p><p>高通给的patch</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/qcom/proprietary/chi-cdk / oem/qcom/feature2/chifeature2graphselector/chifeature2graphselector.cpp</span></span><br><span class="line"><span class="function">VOID <span class="title">ChiFeature2GraphSelector::BuildCameraIdSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Add by junwei.zhou according Qcom case num 04763737</span></span><br><span class="line">    <span class="comment">//fix platform design</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __XIAOMI_CAMERA__</span></span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetSingle &#125;,  SINGLE_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetBokeh &#125;,   BOKEH_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetMulti &#125;,   MULTI_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetFusion &#125;,  FUSION_CAMERA &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetSingle &#125;,  SINGLE_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetMulti &#125;,   MULTI_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetBokeh &#125;,   BOKEH_CAMERA &#125;);</span><br><span class="line">    m_cameraIdMap.insert(&#123; &#123; cameraIdSetFusion &#125;,  FUSION_CAMERA &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分别配置主摄和辅摄的setting</p><ul><li><p>主摄：masterSettings</p></li><li><p>辐摄：slaveSettings</p></li></ul></li></ol><h1 id="Dump-EEprom-Data"><a href="#Dump-EEprom-Data" class="headerlink" title="Dump EEprom Data"></a>Dump EEprom Data</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell <span class="string">&quot;echo dumpSensorEEPROMData=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot;</span></span><br></pre></td></tr></table></figure><p>数据存放位置： <strong>/data/vendor/camera/xxx_kbuffer_OTP.txt</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Bring-Up-Sensor&quot;&gt;&lt;a href=&quot;#Bring-Up-Sensor&quot; class=&quot;headerlink&quot; title=&quot;Bring Up Sensor&quot;&gt;&lt;/a&gt;Bring Up Sensor&lt;/h1&gt;&lt;h2 id=&quot;HAL层的配置&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx capture result 代码流程</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20result%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20result%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:06.000Z</published>
    <updated>2021-01-30T08:33:17.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预览和拍照的-result-代码流程"><a href="#预览和拍照的-result-代码流程" class="headerlink" title="预览和拍照的 result 代码流程"></a>预览和拍照的 result 代码流程</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;预览和拍照的-result-代码流程&quot;&gt;&lt;a href=&quot;#预览和拍照的-result-代码流程&quot; class=&quot;headerlink&quot; title=&quot;预览和拍照的 result 代码流程&quot;&gt;&lt;/a&gt;预览和拍照的 result 代码流程&lt;/h3&gt;</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx capture request 代码流程</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:05.000Z</published>
    <updated>2021-01-30T08:33:17.767Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预览和拍照的-request-代码流程"><a href="#预览和拍照的-request-代码流程" class="headerlink" title="预览和拍照的 request 代码流程"></a>预览和拍照的 request 代码流程</h3><h4 id="主体框架图"><a href="#主体框架图" class="headerlink" title="主体框架图"></a>主体框架图</h4><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20capture%20request%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/image-20201012225025652.png" alt="process capture request"></p><h4 id="详细代码调用流程"><a href="#详细代码调用流程" class="headerlink" title="详细代码调用流程"></a>详细代码调用流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">chi_override_process_request() <span class="comment">//chxextensioninterface.cpp </span></span><br><span class="line">OverrideProcessRequest()   <span class="comment">//chxextensionmodule.cpp </span></span><br><span class="line">    ProcessCaptureRequest()<span class="comment">//chxusecase.cpp</span></span><br><span class="line">    ExecuteCaptureRequest() <span class="comment">//chxadvancedcamerausecase.cpp</span></span><br><span class="line">    result = pFeature-&gt;ExecuteProcessRequest(pRequest); <span class="comment">//会调到chifeature2wrapper.cpp:494 ExecuteProcessRequest()</span></span><br><span class="line">    ExecuteProcessRequest() <span class="comment">//chifeature2wrapper.cpp 开始进入算法的领域</span></span><br><span class="line">                    SubmitRequestToSession() <span class="comment">//经过一系类调用会走到 chifeature2base.cpp </span></span><br><span class="line">                     result = ExtensionModule::GetInstance()-&gt;ActivatePipeline() </span><br><span class="line">                     OnSubmitRequestToSession()</span><br><span class="line">                    ProcessFeatureMessage()</span><br><span class="line">                    ProcessMessageCb() <span class="comment">//通过回调又重新回到 chifeature2wrapper.cpp </span></span><br><span class="line">                    result = pFeature2Wrapper-&gt;m_pUsecaseBase-&gt;SubmitRequest(&amp;submitRequest); <span class="comment">//将 request 下到 camx session 中  </span></span><br></pre></td></tr></table></figure><p>CHI feature 通过 usecase 提交 request 到 session, 套路还是一样的（chxextensionmodule.cpp 通过这条链路转到Camx）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = pSession-&gt;ProcessCaptureRequest(pRequest); <span class="comment">//camxchicontext.cpp feature submit request 会调到这里从这里开始步入 session</span></span><br><span class="line"><span class="function">CamxResult <span class="title">Session::ProcessCaptureRequest</span><span class="params">()</span></span>; <span class="comment">//camxsession.cpp </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;预览和拍照的-request-代码流程&quot;&gt;&lt;a href=&quot;#预览和拍照的-request-代码流程&quot; class=&quot;headerlink&quot; title=&quot;预览和拍照的 request 代码流程&quot;&gt;&lt;/a&gt;预览和拍照的 request 代码流程&lt;/h3&gt;&lt;h4 i</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx config stream 代码流程</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20config%20stream%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20config%20stream%20%E4%BB%A3%E7%A0%81%E6%B5%81%E7%A8%8B/</id>
    <published>2019-12-31T16:00:04.000Z</published>
    <updated>2021-01-30T08:33:17.771Z</updated>
    
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>Arch Linux 开发环境的搭建</title>
    <link href="https://zh-wiki.github.io/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Arch%20Linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Arch%20Linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:03.000Z</published>
    <updated>2021-01-30T08:33:26.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Arch-Linux-系统安装"><a href="#Arch-Linux-系统安装" class="headerlink" title="Arch Linux 系统安装"></a>Arch Linux 系统安装</h1><hr><p>主要进行分区，系统的安装，图形服务和必要驱动的安装</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><ol><li><p>查看当前分区信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure></li><li><p>设置分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfdisk /dev/sda</span><br></pre></td></tr></table></figure><p>1)首先选择分区类型</p><p>​    MBR 选择 dos    </p><p>​    GPT  选择 gpt </p><p> 2)MBR启动一般分为2个分区</p><p>​    主分区   （选择为boot标志）</p><p>​    交换分区（内存的2倍）</p></li><li><p>格式化分区</p><p>格式化主分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br></pre></td></tr></table></figure><p>格式化交换分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkswap /dev/sda2</span><br></pre></td></tr></table></figure><p>启动交换分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapon /dev/sda2</span><br></pre></td></tr></table></figure></li><li><p>挂载分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sda1 /mnt</span><br></pre></td></tr></table></figure></li></ol><h2 id="编辑镜像源"><a href="#编辑镜像源" class="headerlink" title="编辑镜像源"></a>编辑镜像源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure><p>将中国的源放在文件的开头</p><h2 id="安装系统基本组件"><a href="#安装系统基本组件" class="headerlink" title="安装系统基本组件"></a>安装系统基本组件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure><h2 id="安装基本开发工具包"><a href="#安装基本开发工具包" class="headerlink" title="安装基本开发工具包"></a>安装基本开发工具包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S base-devel</span><br></pre></td></tr></table></figure><h2 id="安装-sudo"><a href="#安装-sudo" class="headerlink" title="安装 sudo"></a>安装 sudo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S sudo vi vim</span><br><span class="line">visudo</span><br></pre></td></tr></table></figure><p>删除这一行注释 <strong>%wheel ALL = (ALL) ALL</strong></p><h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">useradd -G wheel -m 用户名</span><br><span class="line">passwad 用户名</span><br></pre></td></tr></table></figure><h2 id="安装-Grub"><a href="#安装-Grub" class="headerlink" title="安装 Grub"></a>安装 Grub</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arch-chroot /mnt</span><br><span class="line">pacman -S grub</span><br><span class="line">grub-install --target=i386-pc /dev/sda</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure><h2 id="生成-fstab"><a href="#生成-fstab" class="headerlink" title="生成 fstab"></a>生成 fstab</h2><p>该配置不需要 arch-chroot </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genfstab /mnt &gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure><h2 id="安装-Xorg-图形管理"><a href="#安装-Xorg-图形管理" class="headerlink" title="安装 Xorg 图形管理"></a>安装 Xorg 图形管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt xorg-server xorg-xinit xorg-apps</span><br></pre></td></tr></table></figure><h2 id="安装网络组件"><a href="#安装网络组件" class="headerlink" title="安装网络组件"></a>安装网络组件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt dhcpcd wpa_supplicant networkmanager</span><br><span class="line">arch-chroot /mnt</span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpcd</span><br><span class="line">systemctl <span class="built_in">enable</span> wpa_supplicant</span><br><span class="line">systemctl <span class="built_in">enable</span> networkmanager</span><br></pre></td></tr></table></figure><h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep VGA//查看显卡是什么型号</span><br><span class="line">pacman -S xf86-video-intel  //intel 显卡驱动</span><br></pre></td></tr></table></figure><h2 id="安装音频组件"><a href="#安装音频组件" class="headerlink" title="安装音频组件"></a>安装音频组件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt alsa-utils pulseaudio</span><br><span class="line">pacstrap /mnt pulseaudio-alsa</span><br></pre></td></tr></table></figure><h2 id="Arch-Linux-桌面环境安装"><a href="#Arch-Linux-桌面环境安装" class="headerlink" title="Arch Linux 桌面环境安装"></a>Arch Linux 桌面环境安装</h2><hr><h2 id="窗口管理器-dwm"><a href="#窗口管理器-dwm" class="headerlink" title="窗口管理器 dwm"></a>窗口管理器 dwm</h2><ol><li><p>安装终端内置浏览器 <strong>w3m</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S w3m</span><br></pre></td></tr></table></figure></li><li><p>下载 <strong>dwm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w3m suckless.org</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make clean install</span><br></pre></td></tr></table></figure></li><li><p>运行dwm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.xinitrc</span><br><span class="line">startx</span><br></pre></td></tr></table></figure><p>在 <strong>.xinitrc</strong> 中 加入 <strong>exec dwm</strong> </p><h1 id="Arch-Linux-基础配置"><a href="#Arch-Linux-基础配置" class="headerlink" title="Arch Linux 基础配置"></a>Arch Linux 基础配置</h1></li></ol><hr><h2 id="安装中文字体"><a href="#安装中文字体" class="headerlink" title="安装中文字体"></a>安装中文字体</h2>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji</span><br><span class="line">sudo vim /etc/locale.gen</span><br></pre></td></tr></table></figure><p>取消 <strong>/etc/locale.gen</strong> 中 以下 的注释</p><ul><li><p>en_US.UTF-8 UTF-8</p></li><li><p>zh_CN.UTF-8 UTF-8</p></li><li><p>zh_TW.UTF-8 UTF-8</p></li></ul><p>生成 locale</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo locale-gen</span><br></pre></td></tr></table></figure><h2 id="设置-archlinuxcn"><a href="#设置-archlinuxcn" class="headerlink" title="设置 archlinuxcn"></a>设置 archlinuxcn</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/pacman.conf</span><br><span class="line">sudo pacman -Sy</span><br><span class="line">sudo pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure><p>在文件的末尾插入</p><p>[archlinuxcn]</p><p>Server = <a href="https://mirrors.ustc.edu.cn/archlinuxcn/$arch">https://mirrors.ustc.edu.cn/archlinuxcn/$arch</a></p><h2 id="安装-Chrome"><a href="#安装-Chrome" class="headerlink" title="安装 Chrome"></a>安装 Chrome</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S google-chrome</span><br></pre></td></tr></table></figure><h2 id="安装中文输入法"><a href="#安装中文输入法" class="headerlink" title="安装中文输入法"></a>安装中文输入法</h2><ol><li><p>安装输入法以及配置工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-qt5 fcitx-gtk2 fcitx-gtk3 fcitx-configtool</span><br></pre></td></tr></table></figure></li><li><p>配置输入法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.xprofile</span><br></pre></td></tr></table></figure><p>输入以下内容</p><p>export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=”@im=fcitx”</p></li></ol><h2 id="SSH-的安装与配置"><a href="#SSH-的安装与配置" class="headerlink" title="SSH 的安装与配置"></a>SSH 的安装与配置</h2><ol><li><p>安装ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy openssh</span><br></pre></td></tr></table></figure></li><li><p>生成密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxx@xxxxx.com&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 SSH 远程连接问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>在文件的末尾加以下配置</p><p>LoginGraceTime 120<br>PermitRootLogin yes<br>StrictModes yes</p></li></ol><h2 id="vscode-zsh-乱码"><a href="#vscode-zsh-乱码" class="headerlink" title="vscode zsh 乱码"></a>vscode zsh 乱码</h2><ol><li><p>设置vscode终端字体</p><p><img src="/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Arch%20Linux%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/image-20201206134507082.png" alt="设置终端字体"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Arch-Linux-系统安装&quot;&gt;&lt;a href=&quot;#Arch-Linux-系统安装&quot; class=&quot;headerlink&quot; title=&quot;Arch Linux 系统安装&quot;&gt;&lt;/a&gt;Arch Linux 系统安装&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;主要进行分区，系统的安装，</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Arch Linux" scheme="https://zh-wiki.github.io/tags/Arch-Linux/"/>
    
  </entry>
  
  <entry>
    <title>高通 Camx Camx open camera</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20open%20camera/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20open%20camera/</id>
    <published>2019-12-31T16:00:03.000Z</published>
    <updated>2021-01-30T08:33:17.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Open-Camera-的流程简介"><a href="#Open-Camera-的流程简介" class="headerlink" title="Open Camera 的流程简介"></a>Open Camera 的流程简介</h1><p>当用户打开了相机设备之后，便会发生如下过程：</p><ol><li>APP调用CameraManager的openCamera方法，层层调用之后最终调用到Camera Service层中的CameraService::connectDevice方法</li><li>然后通过ICameraDevice::open()这一个HIDL接口通知Camera Provider层</li><li>在Camera Provider层内部又通过调用之前获取的camera_module_t中methods的open方法来获取一个Camera 设备，对应于HAL中的camera3_device_t结构体</li><li>在Camera Provider层调用获取到的camera3_device_t的initialize方法进行初始化动作</li></ol><p>代码大概流程走向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//APP 端 open Camera</span></span><br><span class="line">CameraManager::openCamera() </span><br><span class="line">    <span class="comment">//Camera Server</span></span><br><span class="line">    CameraService::connectDevice()</span><br><span class="line">    <span class="comment">//通过HIDL接口</span></span><br><span class="line">    ICameraDevice::open()</span><br><span class="line">    <span class="comment">//camera provider</span></span><br><span class="line">    <span class="keyword">camera_module_t</span>::methods::open()</span><br><span class="line">    <span class="comment">//接下来就是进行一些初始化操作</span></span><br><span class="line">     <span class="keyword">camera3_device_t</span>::initialize()</span><br></pre></td></tr></table></figure><h1 id="APP-Open-Camera-流程"><a href="#APP-Open-Camera-流程" class="headerlink" title="APP Open Camera 流程"></a>APP Open Camera 流程</h1><p>App端主要做了以下几点工作</p><ol><li><p>获取 CameraManager 服务</p></li><li><p>打开指定的 Camera</p><ul><li>获取 Camera Server</li><li>调用 cameraService.connectDevice() 去连接打开设备，并且将上层传下来的回调传入Camera Server</li><li>返回Device给App端</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//apk端获取CameraManager 服务</span></span><br><span class="line">mCamManager = (CameraManager)getSystemService(Context.CAMERA_SERVICE);  </span><br><span class="line"><span class="comment">//打开指定camera</span></span><br><span class="line">--&gt; mCamManager.openCamera(mCameraId, mStateCallback, null);    </span><br><span class="line"><span class="comment">//frameworks/base/core/java/android/hardware/camera2/CameraManager.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull <span class="keyword">final</span> CameraDevice.StateCallback callback)</span></span></span><br><span class="line">   |--&gt; openCameraForUid(cameraId, callback, executor, USE_CALLING_UID)</span><br><span class="line">   |   |--&gt; openCameraDeviceUserAsync(cameraId, callback, executor, clientUid);</span><br><span class="line">   |   |   |--&gt; CameraDevice device = null; <span class="comment">//初始化CameraDevice</span></span><br><span class="line">   |   |   | <span class="comment">//实例化　new android.hardware.camera2.impl.CameraDeviceImpl</span></span><br><span class="line">   |   |   |--&gt; android.hardware.camera2.impl.CameraDeviceImpl deviceImpl = <span class="keyword">new</span> android.hardware.camera2.impl.CameraDeviceImpl(...) </span><br><span class="line">   |   |   |--&gt; ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks();   <span class="comment">//获取回调</span></span><br><span class="line">   |   |   |--&gt; ICameraService cameraService = CameraManagerGlobal.get().getCameraService();    <span class="comment">//获取CameraService 服务</span></span><br><span class="line">   |   |   |--&gt; cameraUser = cameraService.connectDevice(callbacks, cameraId, mContext.getOpPackageName(), uid);    <span class="comment">//连接打开camera</span></span><br><span class="line">   |   |   |--&gt; <span class="keyword">goto</span> CONNECTDEVICE:    <span class="comment">//跳转到下面CONNECTDEVICE处进行分析</span></span><br><span class="line">   |   |   |--&gt; deviceImpl.setRemoteDevice(cameraUser);</span><br><span class="line">   |   |   |   |--&gt; mRemoteDevice = <span class="keyword">new</span> ICameraDeviceUserWrapper(remoteDevice);</span><br><span class="line">   |   |   |   |--&gt; mDeviceExecutor.execute(mCallOnOpened); <span class="comment">//这里是一个线程池</span></span><br><span class="line">   |   |   |   |   |--&gt; sessionCallback = mSessionStateCallback;    <span class="comment">//获取session cb</span></span><br><span class="line">   |   |   |   |   |--&gt; sessionCallback.onOpened(CameraDeviceImpl.<span class="keyword">this</span>);    <span class="comment">//通过session cb 返回device</span></span><br><span class="line">   |   |   |   |   |--&gt; mDeviceCallback.onOpened(CameraDeviceImpl.<span class="keyword">this</span>);    <span class="comment">//通过device cb 返回device,这里就是返回给apk端的CameraDevice了</span></span><br></pre></td></tr></table></figure><h1 id="Camera-Server-Open-流程"><a href="#Camera-Server-Open-流程" class="headerlink" title="Camera Server Open 流程"></a>Camera Server Open 流程</h1><p>对于打开相机设备动作,主要由connectDevice来实现，当CameraFramework通过调用ICameraService的connectDevice接口的时候,主要做了两件事情：</p><ul><li>创建CameraDeviceClient。</li><li>对CameraDeviceClient进行初始化,并将其返回给Framework。</li></ul><h2 id="创建-CameraDevcieClient"><a href="#创建-CameraDevcieClient" class="headerlink" title="创建 CameraDevcieClient"></a>创建 CameraDevcieClient</h2><p>CameraDeviceClient 该类在打开设备的时候被实例化，一次打开设备的操作对应一个该类对象，它实现了ICameraDeviceUser接口，以AIDL方式暴露接口给Camera Framework进行调用，于此同时,该类在打开设备的过程中，获取了来自Camera Framework对于ICameraDeviceCallback接口的实现代理，通过该代理可以将结果上传至Camera Framewor中。我个人的理解其实这个类就是 framework 与 Camera 的通信入口。</p><p>代码流程如下：</p><ul><li>首先实例化一个CameraDeviceClient</li><li>将来自Framework针对ICameraDeviceCallback的实现存入CameraDeviceClient中，一旦有结果产生便可以将结果通过这个回调回传给Framework</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/av/services/camera/libcameraservice/CameraService.cpp</span></span><br><span class="line"><span class="function">Status <span class="title">CameraService::connectDevice</span><span class="params">(<span class="keyword">const</span> sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; cameraCb, <span class="keyword">const</span> String16&amp; cameraId, <span class="keyword">const</span> String16&amp; clientPackageName, <span class="keyword">int</span> clientUid, sp&lt;hardware::camera2::ICameraDeviceUser&gt;* device)</span> <span class="comment">//最后一个参数是返回值</span></span></span><br><span class="line">   |--&gt; connectHelper&lt;hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient&gt;(...) //模板，CALLBACK 为hardware::camera2::ICameraDeviceCallbacks， CLIENT： CameraDeviceClient</span><br><span class="line">   |   |--&gt; validateConnectLocked(...) <span class="comment">//关于一些权限的判断，如果没有权限或者非法访问这里会直接退出</span></span><br><span class="line">   |   |--&gt; <span class="keyword">int</span> deviceVersion = getDeviceVersion(cameraId, <span class="comment">/*out*/</span>&amp;facing) <span class="comment">//获取device version, 为之后的实例化哪一个client 做准备</span></span><br><span class="line">   |   |--&gt; makeClient(..., deviceVersion, effectiveApiLevel, ...) <span class="comment">//这里主要是这两个参数决定了实例化哪一个client，</span></span><br><span class="line">   |   |--&gt; *client = <span class="keyword">new</span> CameraDeviceClient(cameraService, tmp, packageName, cameraId,facing, clientPid, clientUid, servicePid) <span class="comment">//这里是实例化了CameraDeviceClient</span></span><br><span class="line">   |   |--&gt; client = <span class="keyword">static_cast</span>&lt;CLIENT*&gt;(tmp.get()); <span class="comment">//取得makeClient中实例化好的client</span></span><br><span class="line">   |   |--&gt; client-&gt;initialize(mCameraProviderManager, mMonitorTags); <span class="comment">//开始初始化</span></span><br></pre></td></tr></table></figure><h2 id="初始化-CameraDevcieClient"><a href="#初始化-CameraDevcieClient" class="headerlink" title="初始化 CameraDevcieClient"></a>初始化 CameraDevcieClient</h2><p>CameraDeviceClient的初始化工作流程：</p><ul><li>调用父类Camera2ClientBase的initialize方法进行初始化</li><li>实例化FrameProcessorBase对象并且将内部的Camera3Device对象传入其中,这样就建立了和Camera3Device的联系,之后将内部线程运行起来,等待来自Camera3Device的结果</li><li>将CameraDeviceClient注册到内部,这样就建立了与CameraDeviceClient的联系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file : frameworks/av/services/camera/libcameraservice/api2/CameraDeviceClient.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">CameraDeviceClient::initialize</span><span class="params">(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span></span></span><br><span class="line">   |--&gt; initializeImpl(manager, monitorTags)</span><br><span class="line">   |--&gt; mFrameProcessor = <span class="keyword">new</span> FrameProcessorBase(mDevice); <span class="comment">//实例化FrameProcessorBase对象</span></span><br><span class="line">   |   |--&gt; Camera2ClientBase::initialize(providerPtr, monitorTags)</span><br><span class="line">   <span class="comment">//file:  frameworks/av/services/camera/libcameraservice/common/Camera2ClientBase.cpp</span></span><br><span class="line">   |   |--&gt; <span class="keyword">status_t</span> Camera2ClientBase&lt;TClientBase&gt;::initialize(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span><br><span class="line">   |   |   |--&gt; initializeImpl(manager, monitorTags)</span><br><span class="line">   |   |   |   |--&gt; mDevice-&gt;initialize(providerPtr, monitorTags)   <span class="comment">//这里的mDevice 是在 Camera2ClientBase初始化的时候传入的  mDevice(new Camera3Device(cameraId))</span></span><br></pre></td></tr></table></figure><h3 id="Camera3Device-结构介绍"><a href="#Camera3Device-结构介绍" class="headerlink" title="Camera3Device 结构介绍"></a>Camera3Device 结构介绍</h3><ul><li>主要实现了对Camera Provider 的ICameraDeviceCallbacks会调接口的实现，通过该接口接收来自Provider的结果上传进而传给CameraDeviceClient</li><li>Camera3Device会将事件通过notify方法给到CameraDeviceClient</li><li>Camera3Device中RequestThread主要用于处理Request的接收与下发工作</li></ul><p>Camera3Device 初始化</p><ul><li>通过调用CameraProviderManager的openSession方法打开并获取一个Provider中的ICameraDeviceSession代理</li><li>实例化一个HalInterface对象,将之前获取的ICameraDeviceSession代理存入其中,最后将RequestThread线程运行起来,等待request的下发</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: device3/Camera3Device.cpp</span></span><br><span class="line"> <span class="function"><span class="keyword">status_t</span> <span class="title">Camera3Device::initialize</span><span class="params">(sp&lt;CameraProviderManager&gt; manager, <span class="keyword">const</span> String8&amp; monitorTags)</span></span></span><br><span class="line"> |--&gt; status_t res = manager-&gt;openSession(mId.string(), this, /*out*/ &amp;session)   //CameraProviderManager openSession</span><br><span class="line"> <span class="comment">//file: common/CameraProviderManager.cpp</span></span><br><span class="line">   |   |--&gt; <span class="function"><span class="keyword">status_t</span> <span class="title">CameraProviderManager::openSession</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;id, <span class="keyword">const</span> sp&lt;device::V3_2::ICameraDeviceCallback&gt;&amp; callback, sp&lt;device::V3_2::ICameraDeviceSession&gt; *session)</span></span></span><br><span class="line">   |   |   |--&gt; auto interface = deviceInfo3-&gt;startDeviceInterface&lt;CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT&gt;()</span><br><span class="line">   |   |   |   |--&gt; <span class="keyword">const</span> sp&lt;provider::V2_4::ICameraProvider&gt; interface = startProviderInterface()  <span class="comment">//获取provider</span></span><br><span class="line">   |   |   |   |--&gt; interface-&gt;getCameraDeviceInterface_V3_x(name, [&amp;status, &amp;cameraInterface](hidl_cb) <span class="comment">//这里的hidl_cb 指的是回调接口，provider 会将device 指针返回回来，当然这个指针是跨进程能够调用的，具体怎么实现的暂时不清楚，暂且不管</span></span><br><span class="line">   |   |   |--&gt; interface-&gt;open(callback, [&amp;status, &amp;session](Status s, <span class="keyword">const</span> sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession)    <span class="comment">//这里就调用的provider部分的Device的open接口</span></span><br></pre></td></tr></table></figure><h3 id="FrameProcessBase-结构介绍"><a href="#FrameProcessBase-结构介绍" class="headerlink" title="FrameProcessBase 结构介绍"></a>FrameProcessBase 结构介绍</h3><ul><li>meta data以及image data 会给到 FrameProcessBase</li><li>FrameProcessBase主要用于metadata以及image data的中转处理</li></ul><h1 id="Provider-Open-流程"><a href="#Provider-Open-流程" class="headerlink" title="Provider Open 流程"></a>Provider Open 流程</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: device/3.2/default/CameraDevice.cpp</span></span><br><span class="line"><span class="function">Return&lt;<span class="keyword">void</span>&gt; <span class="title">CameraDevice::open</span><span class="params">(<span class="keyword">const</span> sp&lt;ICameraDeviceCallback&gt;&amp; callback, ICameraDevice::open_cb _hidl_cb)</span></span></span><br><span class="line"><span class="function"> <span class="comment">//这里的mModule 是CameraModule实例，在provider调用etCameraDeviceInterface_V3_x 方法时通过实例化device deviceImpl = new </span></span></span><br><span class="line"><span class="function"> <span class="comment">//android::hardware::camera::device::V3_4::implementation::CameraDevice(mModule, cameraId, mCameraDeviceNames) 传入，</span></span></span><br><span class="line"><span class="function"> <span class="comment">//而mModule 是在provider初始化的时候创建，里面获取了camera hw module实例,关于proviser的初始化参见provider_initialize</span></span></span><br><span class="line"> |--&gt; mModule-&gt;open(mCameraId.c_str(), reinterpret_cast&lt;hw_device_t**&gt;(&amp;device)) </span><br><span class="line"> <span class="comment">//file: common/1.0/default/CameraModule.cpp</span></span><br><span class="line"> |--&gt; <span class="function"><span class="keyword">int</span> <span class="title">CameraModule::open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* id, struct <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"> |   |--&gt; filterOpenErrorCode(mModule-&gt;common.methods-&gt;open(&amp;mModule-&gt;common, id, device))</span><br></pre></td></tr></table></figure><h1 id="Camx-Open-流程"><a href="#Camx-Open-流程" class="headerlink" title="Camx Open 流程"></a>Camx Open 流程</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Open-Camera-的流程简介&quot;&gt;&lt;a href=&quot;#Open-Camera-的流程简介&quot; class=&quot;headerlink&quot; title=&quot;Open Camera 的流程简介&quot;&gt;&lt;/a&gt;Open Camera 的流程简介&lt;/h1&gt;&lt;p&gt;当用户打开了相机设备</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>Centos 开发环境的搭建</title>
    <link href="https://zh-wiki.github.io/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Centos%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Centos%20%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2021-01-30T08:33:26.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同一网段外部浏览器不能访问Tomcat"><a href="#同一网段外部浏览器不能访问Tomcat" class="headerlink" title="同一网段外部浏览器不能访问Tomcat"></a>同一网段外部浏览器不能访问Tomcat</h2><ol><li><p>问题产生背景和原因</p><p>背景：服务器已经安装好tomcat, 服务器主机通过 <strong>ip+8080</strong> 的方式可以进行访问, 但是其他在同一网段下的客户端机器通过同样方式不能访问.</p><p>原因：服务器未将 8080 端口进行开放</p></li><li><p>解决方法</p><p>1)查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure><p>2)添加需要开放的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=8080/tcp</span><br></pre></td></tr></table></figure><p>3)加载配置使其生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>4)查看配置是否生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --list-ports</span><br></pre></td></tr></table></figure><p>5)重新访问 Tomcat <strong>(IP+8080)</strong> </p></li></ol><h2 id="防火墙的相关操作"><a href="#防火墙的相关操作" class="headerlink" title="防火墙的相关操作"></a>防火墙的相关操作</h2><ol><li><p>开启防火墙的命令  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>关闭防火墙的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>开机自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>关闭开机自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>查看防火墙状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;同一网段外部浏览器不能访问Tomcat&quot;&gt;&lt;a href=&quot;#同一网段外部浏览器不能访问Tomcat&quot; class=&quot;headerlink&quot; title=&quot;同一网段外部浏览器不能访问Tomcat&quot;&gt;&lt;/a&gt;同一网段外部浏览器不能访问Tomcat&lt;/h2&gt;&lt;ol&gt;
</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Centos" scheme="https://zh-wiki.github.io/tags/Centos/"/>
    
  </entry>
  
  <entry>
    <title>Repo 常用命令</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Repo%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Repo%20%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2021-01-30T08:33:26.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="repo-拉下来的代码如何新建分支"><a href="#repo-拉下来的代码如何新建分支" class="headerlink" title="repo 拉下来的代码如何新建分支"></a>repo 拉下来的代码如何新建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo start xxx(分支名) --all</span><br></pre></td></tr></table></figure><h3 id="repo-sync-的时候如果有本地未提交的修改"><a href="#repo-sync-的时候如果有本地未提交的修改" class="headerlink" title="repo sync 的时候如果有本地未提交的修改"></a>repo sync 的时候如果有本地未提交的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo forall -cv <span class="string">&quot;git reset HEAD --hard; git clean -df &quot;</span> -j32</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;repo-拉下来的代码如何新建分支&quot;&gt;&lt;a href=&quot;#repo-拉下来的代码如何新建分支&quot; class=&quot;headerlink&quot; title=&quot;repo 拉下来的代码如何新建分支&quot;&gt;&lt;/a&gt;repo 拉下来的代码如何新建分支&lt;/h3&gt;&lt;figure class</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Linux 命令" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"/>
    
    
  </entry>
  
  <entry>
    <title>高通 Camx camera provider</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/</id>
    <published>2019-12-31T16:00:02.000Z</published>
    <updated>2021-01-30T08:33:17.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201021102734471.png" alt="camera provider" style="zoom:80%;"><p>通过图片可以看出Camera Provider 分为两部分</p><ul><li>通过 <strong>HIDL</strong> 与Camera Service 跨进程通信</li><li>通过 <strong>dlopen</strong> 方式加载一系列动态库 （Camera HAL3结构的so），在高通Camera 是指 camx-chi 架构</li></ul><h1 id="camera-provider-和-camera-hal3-的联系"><a href="#camera-provider-和-camera-hal3-的联系" class="headerlink" title="camera provider 和 camera hal3 的联系"></a>camera provider 和 camera hal3 的联系</h1><p>HAL硬件抽象层(Hardware Abstraction Layer),是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层，该层定义了自己的一套通用标准接口,平台厂商务必按照以下规则定义自己的Module</p><ul><li>每一个硬件都通过hw_module_t来描述,具有固定的名字HMI</li><li>每一个硬件都必须实现hw_module_t里面的open方法,用于打开硬件设备,并返回对应的操作接口集合</li><li>硬件的操作接口集合使用hw_device_t 来描述,并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合</li></ul><h2 id="HAL3-结构体介绍"><a href="#HAL3-结构体介绍" class="headerlink" title="HAL3 结构体介绍"></a>HAL3 结构体介绍</h2><details><summary>hw_module_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="keyword">uint16_t</span> module_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_major module_api_version</span></span><br><span class="line">    <span class="keyword">uint16_t</span> hal_api_version;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> version_minor hal_api_version</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>hw_module_methods_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Open a specific device */</span></span><br><span class="line">    <span class="keyword">int</span> (*open)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id,</span><br><span class="line">            struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line">&#125; <span class="keyword">hw_module_methods_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>hw_device_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tag;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span>* <span class="title">module</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint64_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">12</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> (*close)(struct <span class="keyword">hw_device_t</span>* device);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">hw_device_t</span>;</span><br></pre></td></tr></table></figure></details><p>从上面的定义可以看出</p><ul><li><p>hw_module_t 代表了模块，通过其open方法用来打开一个设备</p></li><li><p>设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外,并无其它方法</p></li><li><p>由此可见谷歌定义的HAL接口,并不能满足绝大部分HAL模块的需要,所以谷歌想出了一个比较好的解决方式,那便是将这两个基本结构嵌入到更大的结构体内部,同时在更大的结构内部定义了各自模块特有的方法,用于实现模块的功能,这样,一来对上保持了HAL的统一规范,二来也扩展了模块的功能</p></li></ul><h2 id="高通-camx-HAL3-结构体"><a href="#高通-camx-HAL3-结构体" class="headerlink" title="高通 camx HAL3 结构体"></a>高通 camx HAL3 结构体</h2><details><summary>camera_module_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera_module</span> &#123;</span></span><br><span class="line">    <span class="keyword">hw_module_t</span> common;</span><br><span class="line">    <span class="keyword">int</span> (*get_number_of_cameras)(<span class="keyword">void</span>);</span><br><span class="line">    <span class="keyword">int</span> (*get_camera_info)(<span class="keyword">int</span> camera_id, struct camera_info *info);</span><br><span class="line">    <span class="keyword">int</span> (*set_callbacks)(<span class="keyword">const</span> <span class="keyword">camera_module_callbacks_t</span> *callbacks);</span><br><span class="line">    <span class="keyword">void</span> (*get_vendor_tag_ops)(<span class="keyword">vendor_tag_ops_t</span>* ops);</span><br><span class="line">    <span class="keyword">int</span> (*open_legacy)(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* id, <span class="keyword">uint32_t</span> halVersion, struct <span class="keyword">hw_device_t</span>** device);</span><br><span class="line">    <span class="keyword">int</span> (*set_torch_mode)(<span class="keyword">const</span> <span class="keyword">char</span>* camera_id, <span class="keyword">bool</span> enabled);</span><br><span class="line">    <span class="keyword">int</span> (*init)();</span><br><span class="line">    <span class="keyword">int</span> (*get_physical_camera_info)(<span class="keyword">int</span> physical_camera_id,  <span class="keyword">camera_metadata_t</span> **static_metadata);</span><br><span class="line">    <span class="keyword">int</span> (*is_stream_combination_supported)(<span class="keyword">int</span> camera_id, <span class="keyword">const</span> <span class="keyword">camera_stream_combination_t</span> *streams);</span><br><span class="line">    <span class="keyword">void</span> (*notify_device_state_change)(<span class="keyword">uint64_t</span> deviceState);</span><br><span class="line">    <span class="keyword">int</span> (*get_camera_device_version)(<span class="keyword">int</span> camera_id, <span class="keyword">uint32_t</span> *version);</span><br><span class="line">    <span class="keyword">void</span>* reserved[<span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">camera_module_t</span>;</span><br></pre></td></tr></table></figure></details><details><summary>camera3_device_t</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">camera3_device</span> &#123;</span></span><br><span class="line">    <span class="keyword">hw_device_t</span> common;</span><br><span class="line">    <span class="keyword">camera3_device_ops_t</span> *ops;</span><br><span class="line">    <span class="keyword">void</span> *priv;</span><br><span class="line">&#125; <span class="keyword">camera3_device_t</span>;</span><br></pre></td></tr></table></figure></details><ul><li>camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法</li><li>camera3_device_t包含了hw_device_t,主要用来表示Camera设备,其中定义了camera3_device_ops操作方法集合,用来实现正常获取图像数据以及控制Camera的功能</li></ul><h2 id="Camera-HAL3-的实现"><a href="#Camera-HAL3-的实现" class="headerlink" title="Camera HAL3 的实现"></a>Camera HAL3 的实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CAMX_VISIBILITY_PUBLIC <span class="keyword">camera_module_t</span> HAL_MODULE_INFO_SYM =</span><br><span class="line">&#123;</span><br><span class="line">    .common =</span><br><span class="line">    &#123;</span><br><span class="line">        .tag                = HARDWARE_MODULE_TAG,</span><br><span class="line">        .module_api_version = CAMERA_MODULE_API_VERSION_CURRENT,</span><br><span class="line">        .hal_api_version    = HARDWARE_HAL_API_VERSION,</span><br><span class="line">        .id                 = CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">        .name               = <span class="string">&quot;QTI Camera HAL&quot;</span>,</span><br><span class="line">        .author             = <span class="string">&quot;Qualcomm Technologies, Inc.&quot;</span>,</span><br><span class="line">        .methods            = &amp;CamX::g_hwModuleMethods</span><br><span class="line">    &#125;,</span><br><span class="line">    .get_number_of_cameras  = CamX::get_number_of_cameras,</span><br><span class="line">    .get_camera_info        = CamX::get_camera_info,</span><br><span class="line">    .set_callbacks          = CamX::set_callbacks,</span><br><span class="line">    .get_vendor_tag_ops     = CamX::get_vendor_tag_ops,</span><br><span class="line">    .open_legacy            = <span class="literal">NULL</span>,</span><br><span class="line">    .set_torch_mode         = CamX::set_torch_mode,</span><br><span class="line">    .init                   = CamX::init</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没错高通 camx hal3 的入口就是这个，在遵循HAL3规范的前提下，实例化各个接口。Provider 将会调用 hw_get_module() 来获取该入口。</p><p>各个接口映射到 camxhal3.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Dispatch <span class="title">g_dispatchHAL3</span><span class="params">(&amp;g_jumpTableHAL3)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JumpTableHAL3 g_jumpTableHAL3 =</span><br><span class="line">&#123;</span><br><span class="line">    open,</span><br><span class="line">    get_number_of_cameras,</span><br><span class="line">    get_camera_info,</span><br><span class="line">    set_callbacks,</span><br><span class="line">    get_vendor_tag_ops,</span><br><span class="line">    open_legacy,</span><br><span class="line">    set_torch_mode,</span><br><span class="line">    init,</span><br><span class="line">    get_tag_count,</span><br><span class="line">    get_all_tags,</span><br><span class="line">    get_section_name,</span><br><span class="line">    get_tag_name,</span><br><span class="line">    get_tag_type,</span><br><span class="line">    close,</span><br><span class="line">    initialize,</span><br><span class="line">    configure_streams,</span><br><span class="line">    construct_default_request_settings,</span><br><span class="line">    process_capture_request,</span><br><span class="line">    dump,</span><br><span class="line">    flush,</span><br><span class="line">    camera_device_status_change,</span><br><span class="line">    torch_mode_status_change,</span><br><span class="line">    process_capture_result,</span><br><span class="line">    notify</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="Provider-init-代码流程"><a href="#Provider-init-代码流程" class="headerlink" title="Provider init 代码流程"></a>Provider init 代码流程</h1><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201021143242020.png" alt="init 代码流程"></p><p>在系统初始化的时候，系统会去运行”<a href="mailto:&#97;&#x6e;&#x64;&#114;&#111;&#105;&#x64;&#x2e;&#104;&#x61;&#x72;&#100;&#x77;&#97;&#x72;&#x65;&#x2e;&#99;&#x61;&#x6d;&#x65;&#114;&#x61;&#x2e;&#112;&#x72;&#111;&#x76;&#105;&#100;&#x65;&#x72;&#64;&#x32;&#46;&#x34;&#45;&#x73;&#x65;&#114;&#118;&#x69;&#x63;&#101;&#95;&#x36;&#x34;">&#97;&#x6e;&#x64;&#114;&#111;&#105;&#x64;&#x2e;&#104;&#x61;&#x72;&#100;&#x77;&#97;&#x72;&#x65;&#x2e;&#99;&#x61;&#x6d;&#x65;&#114;&#x61;&#x2e;&#112;&#x72;&#111;&#x76;&#105;&#100;&#x65;&#x72;&#64;&#x32;&#46;&#x34;&#45;&#x73;&#x65;&#114;&#118;&#x69;&#x63;&#101;&#95;&#x36;&#x34;</a>“程序启动Provider进程，并加入HW Service Manager中接受统一管理。在改过程中实例化一个 LegacyCameraProviderImpl_2_4 对象，通过 hw_get_module 标准方法 获取HAL 模块。这边指的是 <strong>camera.qcom.so</strong> 。</p><h2 id="Camera-Provider-Init-函数总括"><a href="#Camera-Provider-Init-函数总括" class="headerlink" title="Camera Provider Init 函数总括"></a>Camera Provider Init 函数总括</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LegacyCameraProviderImpl_2_4::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">camera_module_t</span> *rawModule;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取 camera.qcom.so 可以理解为和 camxhal3entry.cpp 建立联系</span></span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (<span class="keyword">const</span> <span class="keyword">hw_module_t</span> **)&amp;rawModule); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将 camera.qcom.so 获取的句柄保存在 mModule 对象中 ，该函数定义在 CameraModule.cpp </span></span><br><span class="line">    mModule = <span class="keyword">new</span> CameraModule(rawModule);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们可以跟进去看看 init() 非常明显 实际就是进行 camx 的初始化，camxhal3entry.cpp  &#123; CAMX:: init()&#125; </span></span><br><span class="line">    <span class="comment">//int CameraModule::init() 这个函数将会调用 getNumberOfCameras() </span></span><br><span class="line">    <span class="comment">//就此 camx-chi 的一系列初始化操作 拉开序幕</span></span><br><span class="line">    err = mModule-&gt;init(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置回调函数，用于接受camx-chi的数据和事件</span></span><br><span class="line">    err = mModule-&gt;setCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// mInitFailed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init 函数结束之后，Camera Provider进程便一直便存在于系统中,监听着来自Camera Service的调用。</p><h2 id="Camera-Provider-Init-分解"><a href="#Camera-Provider-Init-分解" class="headerlink" title="Camera Provider Init 分解"></a>Camera Provider Init 分解</h2><p>通过上面的总括可以理解为 <strong>Provider</strong> 最终目的获取 <strong>Camx-Chi</strong> 的 <strong>setting</strong> 以及 <strong>HW</strong> 资源。然后保存起来返回给上层，供后面使用。</p><p>二话不说先上一张大图</p><p><img src="/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver/%E9%AB%98%E9%80%9A%20Camx/%E9%AB%98%E9%80%9A%20Camx%20camera%20provider/image-20201026113612765.png"></p><h3 id="get-number-of-cameras-函数介绍"><a href="#get-number-of-cameras-函数介绍" class="headerlink" title="get_number_of_cameras 函数介绍"></a>get_number_of_cameras 函数介绍</h3><p>这个函数是一切美好的开始，她的最先调用就是上面介绍的provide init 函数的 <strong>CameraModule::init()</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hardware/interfaces/camera/common/1.0/default/CameraModule.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CameraModule::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int</span> res = OK;</span><br><span class="line">    <span class="keyword">if</span> (getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp;</span><br><span class="line">            mModule-&gt;init != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ATRACE_BEGIN(<span class="string">&quot;camera_module-&gt;init&quot;</span>);</span><br><span class="line">        res = mModule-&gt;init();</span><br><span class="line">        ATRACE_END();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3.cpp中</span></span><br><span class="line">    mNumberOfCameras = getNumberOfCameras();</span><br><span class="line">    mCameraInfoMap.setCapacity(mNumberOfCameras);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CameraModule::init()</strong> ，这个函数调用 <strong>getNumberOfCameras()</strong> 。最终调用到 <strong>get_number_of_cameras()</strong> 这个函数已经是干到camx了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/hal/camxhal3.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_number_of_cameras</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    INT numCameras;</span><br><span class="line">    <span class="comment">//将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp中</span></span><br><span class="line">    <span class="comment">//会调用到 HAL3Module的构造函数</span></span><br><span class="line">    numCameras = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(HAL3Module::GetInstance()-&gt;GetNumCameras());</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> numCameras;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要有两个作用：</p><ul><li>是通过 <strong>HAL3Module</strong> 类的构造函数会获取 CAMX-CHI 的信息</li><li>加载 <strong>com.qti.chi.override.so</strong>  模块，映射 CAMX-CHI 之间的接口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp</span></span><br><span class="line">HAL3Module::HAL3Module()</span><br><span class="line">&#123;</span><br><span class="line">    CamxResult result = CamxResultSuccess;</span><br><span class="line">    CSLCameraPlatform CSLPlatform = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;***************************************************&quot;</span>);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;SHA1:     %s&quot;</span>, CAMX_SHA1);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;COMMITID: %s&quot;</span>, CAMX_COMMITID);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;BUILD TS: %s&quot;</span>, CAMX_BUILD_TS);</span><br><span class="line">    CAMX_LOG_CONFIG(CamxLogGroupHAL, <span class="string">&quot;***************************************************&quot;</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//到了这个位置已经是很亲切了，干到camx了</span></span><br><span class="line">    m_pStaticSettings = HwEnvironment::GetInstance()-&gt;GetStaticSettings();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HwEnvironment-Initialize-函数介绍"><a href="#HwEnvironment-Initialize-函数介绍" class="headerlink" title="HwEnvironment::Initialize() 函数介绍"></a>HwEnvironment::Initialize() 函数介绍</h3><p>通过 <strong>HAL3Module</strong> 构造函数会调用 <strong>HwEnvironment</strong> 类的构造，主体功能在 <strong>HwEnvironment::Initialize()</strong> 中实现</p><details><summary>HwEnvironment::Initialize()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxhwenvironment.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">HwEnvironment::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult              result                  = CamxResultSuccess;</span><br><span class="line">    CSLInitializeParams     params                  = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SettingsManager*        pStaticSettingsManager  = SettingsManager::Create(<span class="literal">NULL</span>);</span><br><span class="line">    ExternalComponentInfo*  pExternalComponent      = GetExternalComponent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != pStaticSettingsManager)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> StaticSettings* pStaticSettings = pStaticSettingsManager-&gt;GetStaticSettings();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != pStaticSettings)</span><br><span class="line">        &#123;</span><br><span class="line">            params.mode                                           = pStaticSettings-&gt;CSLMode;</span><br><span class="line">            params.emulatedSensorParams.enableSensorSimulation    = pStaticSettings-&gt;enableSensorEmulation;</span><br><span class="line">            params.emulatedSensorParams.dumpSensorEmulationOutput = pStaticSettings-&gt;dumpSensorEmulationOutput;</span><br><span class="line"></span><br><span class="line">            OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulatorPath,</span><br><span class="line">                             pStaticSettings-&gt;sensorEmulatorPath,</span><br><span class="line">                             <span class="keyword">sizeof</span>(pStaticSettings-&gt;sensorEmulatorPath));</span><br><span class="line"></span><br><span class="line">            OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulator,</span><br><span class="line">                             pStaticSettings-&gt;sensorEmulator,</span><br><span class="line">                             <span class="keyword">sizeof</span>(pStaticSettings-&gt;sensorEmulator));</span><br><span class="line"></span><br><span class="line">            result = CSLInitialize(&amp;params);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Query the camera platform</span></span><br><span class="line">                result = QueryHwContextStaticEntryMethods();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pHwFactory = m_staticEntryMethods.CreateHwFactory();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pHwFactory)</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_ASSERT_ALWAYS_MESSAGE(<span class="string">&quot;Failed to create the HW factory&quot;</span>);</span><br><span class="line">                    result = CamxResultEFailed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_pSettingsManager = m_pHwFactory-&gt;CreateSettingsManager();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == m_pSettingsManager)</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_ASSERT_ALWAYS_MESSAGE(<span class="string">&quot;Failed to create the HW settings manager&quot;</span>);</span><br><span class="line">                    result = CamxResultEFailed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">            &#123;</span><br><span class="line">                m_staticEntryMethods.GetHWBugWorkarounds(&amp;m_workarounds);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pStaticSettingsManager-&gt;Destroy();</span><br><span class="line">        pStaticSettingsManager = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CAMX_ASSERT(<span class="literal">NULL</span> != pExternalComponent);</span><br><span class="line">    <span class="keyword">if</span> ((CamxResultSuccess == result) &amp;&amp; (<span class="literal">NULL</span> != pExternalComponent))</span><br><span class="line">    &#123;</span><br><span class="line">        result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Load the OEM sensor capacity customization functions</span></span><br><span class="line">        CAMXCustomizeCAMXInterface camxInterface;</span><br><span class="line">        camxInterface.pGetHWEnvironment = HwEnvironment::GetInstance;</span><br><span class="line">        CAMXCustomizeEntry(&amp;m_pOEMInterface, &amp;camxInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess != result)</span><br><span class="line">    &#123;</span><br><span class="line">        CAMX_LOG_ERROR(CamxLogGroupCore, <span class="string">&quot;FATAL ERROR: Raise SigAbort. HwEnvironment initialization failed&quot;</span>);</span><br><span class="line">        m_numberSensors = <span class="number">0</span>;</span><br><span class="line">        OsUtils::RaiseSignalAbort();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_initCapsStatus = InitCapsInitialize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>通过上面的代码可以看出 <strong>HwEnvironment::Initialize()</strong> 做的事情还是挺多的。下面我们开始分析</p><ol><li><p>获取camx的相关配置</p><p>SettingsManager*        pStaticSettingsManager  = SettingsManager::Create(NULL);</p><p>经过一系列调用最终会调到以下代码，加载配置参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxsettingsmanager.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">SettingsManager::Initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    StaticSettings* pStaticSettings)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......    </span><br><span class="line">        <span class="comment">// Populate the default settings</span></span><br><span class="line">        InitializeDefaultSettings();</span><br><span class="line">        InitializeDefaultDebugSettings();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Load the override settings from our override settings stores</span></span><br><span class="line">        result = LoadOverrideSettings(m_pOverrideSettingsStore);</span><br><span class="line">        result = LoadOverrideProperties(m_pOverrideSettingsStore, TRUE);</span><br><span class="line">        result = ValidateSettings();</span><br><span class="line"></span><br><span class="line">        DumpSettings();</span><br><span class="line">        m_pOverrideSettingsStore-&gt;DumpOverriddenSettings();</span><br><span class="line">    ......</span><br><span class="line">    UpdateLogSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用加载好的配置参数去初始化相关模块</p><p>result = CSLInitialize(&amp;params);</p><p>经过一个跳转表格进入以下代码</p><details><summary>CamxResult CSLInitializeHW()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/csl/hw/camxcslhw.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">CSLInitializeHW</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult result                          = CamxResultEFailed;</span><br><span class="line">    CHAR       syncDeviceName[CSLHwMaxDevName] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FALSE == CSLHwIsHwInstanceValid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideodevice, CAM_VNODE_DEVICE_TYPE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdevice, CAM_CPAS_DEVICE_TYPE))</span><br><span class="line">            &#123;</span><br><span class="line">                CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Platform family=%d, version=%d.%d.%d, cpas version=%d.%d.%d&quot;</span>,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.family,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.majorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.minorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.platformVersion.revVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.majorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.minorVersion,</span><br><span class="line">                    g_CSLHwInstance.pCameraPlatform.CPASVersion.revVersion);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (FALSE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdeviceAll, <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;No KMD devices found&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Total KMD subdevices found =%d&quot;</span>, g_CSLHwInstance.kmdDeviceCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Init the memory manager data structures here</span></span><br><span class="line">                CamX::Utils::Memset(g_CSLHwInstance.memManager.bufferInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_CSLHwInstance.memManager.bufferInfo));</span><br><span class="line">                <span class="comment">// Init the sync manager here</span></span><br><span class="line">                g_CSLHwInstance.lock-&gt;Lock();</span><br><span class="line">                g_CSLHwInstance.pSyncFW = CamX::SyncManager::GetInstance();</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> != g_CSLHwInstance.pSyncFW)</span><br><span class="line">                &#123;</span><br><span class="line">                    CSLHwGetSyncHwDevice(syncDeviceName, CSLHwMaxDevName);</span><br><span class="line">                    CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Sync device found = %s&quot;</span>, syncDeviceName);</span><br><span class="line">                    result = g_CSLHwInstance.pSyncFW-&gt;Initialize(syncDeviceName);</span><br><span class="line">                    <span class="keyword">if</span> (CamxResultSuccess != result)</span><br><span class="line">                    &#123;</span><br><span class="line">                        CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;CSL failed to initialize SyncFW&quot;</span>);</span><br><span class="line">                        result = g_CSLHwInstance.pSyncFW-&gt;Destroy();</span><br><span class="line">                        g_CSLHwInstance.pSyncFW = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                g_CSLHwInstance.lock-&gt;Unlock();</span><br><span class="line">                CSLHwInstanceSetState(CSLHwValidState);</span><br><span class="line">                result = CamxResultSuccess;</span><br><span class="line">                CAMX_LOG_VERBOSE(CamxLogGroupCSL, <span class="string">&quot;Successfully acquired requestManager&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;Failed to acquire CPAS&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;Failed to acquire requestManager invalid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CAMX_LOG_ERROR(CamxLogGroupCSL, <span class="string">&quot;CSL in Invalid State&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这一部分我个人理解为，遍历所有kernel端的设备。获取相关接口以及需要的事件。与HAL层建立联系。具体分析以后可以单独写一篇文章分析</p></li><li><p>根据平台获取对应的入口方法</p><p>这个暂时不知道是个什么鬼，先这样理解</p><p>result = QueryHwContextStaticEntryMethods();</p><p>经过一系列的调用最终是跑到了这里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/csl/hwl/titan17x/camxtitan17xhwl.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">Titan17xGetStaticEntryMethods</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HwContextStaticEntry* pStaticEntry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult result = CamxResultSuccess;</span><br><span class="line"></span><br><span class="line">    pStaticEntry-&gt;Create                               = &amp;Titan17xContext::Create;</span><br><span class="line">    pStaticEntry-&gt;GetStaticMetadataKeysInfo            = &amp;Titan17xContext::GetStaticMetadataKeysInfo;</span><br><span class="line">    pStaticEntry-&gt;GetStaticCaps                        = &amp;Titan17xContext::GetStaticCaps;</span><br><span class="line">    pStaticEntry-&gt;CreateHwFactory                      = &amp;Titan17xFactory::Create;</span><br><span class="line">    pStaticEntry-&gt;QueryVendorTagsInfo                  = &amp;Titan17xContext::QueryVendorTagsInfo;</span><br><span class="line">    pStaticEntry-&gt;GetHWBugWorkarounds                  = &amp;Titan17xContext::GetHWBugWorkarounds;</span><br><span class="line">    pStaticEntry-&gt;QueryExternalComponentVendorTagsInfo = &amp;Titan17xContext::QueryExternalComponentVendorTagsInfo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取CHI各个节点的接口</p><p>result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent);</p><p>遍历所有chi相关的.so库，将各个接口保存起来。这一块的代码撸的比较少，先记录这么多</p></li></ol><p>到此处 HwEnvironment::Initialize() 这个函数就介绍的差不多了。日后慢慢完善</p><h3 id="HwEnvironment-InitCaps-函数介绍"><a href="#HwEnvironment-InitCaps-函数介绍" class="headerlink" title="HwEnvironment::InitCaps()  函数介绍"></a>HwEnvironment::InitCaps()  函数介绍</h3><details><summary>HwEnvironment::InitCaps()</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/coer/camxhwenvironment.cpp</span></span><br><span class="line"><span class="function">VOID <span class="title">HwEnvironment::InitCaps</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CamxResult    result = CamxResultSuccess;</span><br><span class="line"></span><br><span class="line">    m_pHWEnvLock-&gt;Lock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InitCapsRunning == m_initCapsStatus ||</span><br><span class="line">        InitCapsDone == m_initCapsStatus)</span><br><span class="line">    &#123;</span><br><span class="line">        m_pHWEnvLock-&gt;Unlock();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_initCapsStatus = InitCapsRunning;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        EnumerateDevices();</span><br><span class="line">        ProbeImageSensorModules();</span><br><span class="line">        EnumerateSensorDevices();</span><br><span class="line">        InitializeSensorSubModules();</span><br><span class="line">        InitializeSensorStaticCaps();</span><br><span class="line"></span><br><span class="line">        result = m_staticEntryMethods.GetStaticCaps(&amp;m_platformCaps[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// copy the static capacity to remaining sensor&#x27;s</span></span><br><span class="line">        <span class="keyword">for</span> (UINT index = <span class="number">1</span>; index &lt; m_numberSensors; index++)</span><br><span class="line">        &#123;</span><br><span class="line">            Utils::Memcpy(&amp;m_platformCaps[index], &amp;m_platformCaps[<span class="number">0</span>], <span class="keyword">sizeof</span>(m_platformCaps[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps)</span><br><span class="line">        &#123;</span><br><span class="line">            m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps(&amp;m_platformCaps[<span class="number">0</span>], m_numberSensors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CAMX_ASSERT(CamxResultSuccess == result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CamxResultSuccess == result)</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeHwEnvironmentStaticCaps();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_initCapsStatus = InitCapsDone;</span><br><span class="line"></span><br><span class="line">    m_pHWEnvLock-&gt;Unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><p>这一波操作应该就是枚举各个Camera模组，检测硬件是否可以通信成功。</p><ol><li><p>Probe Sensor </p><p>经过上述函数中 ProbeImageSensorModules() 会走到  ImageSensorModuleData::Probe()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/proprietary/camx/src/core/camximagesensormoduledata.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">ImageSensorModuleData::Probe</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         BOOL*   pDetected,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         INT32*  pDeviceIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取上下电时序</span></span><br><span class="line">    UINT powerUpCmdSize     = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(TRUE);</span><br><span class="line">    UINT powerDownCmdSize   = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建命令包管理</span></span><br><span class="line">    result = CmdBufferManager::Create(<span class="string">&quot;ImageSensorPacketManager&quot;</span>, &amp;packetResourceParams, &amp;pPacketManager);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向CSL下发probe命令</span></span><br><span class="line">    result = CSLImageSensorProbe(pProbePacket-&gt;GetMemHandle(), pProbePacket-&gt;GetOffset(), &amp;probeResult);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的主要作用就是创建probe sensor 的命令包，然后下发到CSL</p><p>将命令包提交到 CSL 通过ioctl下发到 Kernel</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vendor/qcom/proprietary/camx/src/csl/hw/camxcslhwinternalsensor.cpp</span></span><br><span class="line"><span class="function">CamxResult <span class="title">CSLHwInternalProbeSensorHW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                                          CSLMemHandle hPacket,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          SIZE_T       offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          INT32*       pDeviceIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ioctlCmd.op_code     = CAM_SENSOR_PROBE_CMD;</span><br><span class="line">    ioctlCmd.size        = <span class="keyword">sizeof</span>(ioctlCmd.handle);</span><br><span class="line">    ioctlCmd.handle_type = CAM_HANDLE_MEM_HANDLE;</span><br><span class="line">    ioctlCmd.reserved    = <span class="number">0</span>;</span><br><span class="line">    ioctlCmd.handle      = hPacket;</span><br><span class="line">    result = pLoophw-&gt;deviceOp.Ioctl(pLoophw, VIDIOC_CAM_CONTROL, &amp;ioctlCmd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;img src=&quot;/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera%20Driver</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Camera Driver" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"/>
    
    <category term="高通 Camx" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"/>
    
    
    <category term="高通Camx" scheme="https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客搭建</title>
    <link href="https://zh-wiki.github.io/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>https://zh-wiki.github.io/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2021-01-30T08:33:26.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install --unsafe-perm --verbose -g hexo</span><br></pre></td></tr></table></figure><h1 id="同步本地图片与网络图片"><a href="#同步本地图片与网络图片" class="headerlink" title="同步本地图片与网络图片"></a>同步本地图片与网络图片</h1><hr><ol><li><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure></li><li><p>配置Typora</p><p><img src="/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20201005210350281.png" alt="image-20201005210350281"></p></li><li><p>编译</p><p>有以下log说明配置成功</p><img src="/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20201005165756877.png"></li></ol><h1 id="Wikitten-主题关闭自动标号"><a href="#Wikitten-主题关闭自动标号" class="headerlink" title="Wikitten 主题关闭自动标号"></a>Wikitten 主题关闭自动标号</h1><hr><p><strong>修改路径文件：/themes/Wikitten/layout/common/article.ejs</strong></p><p><img src="/undefined/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20210104093922296.png" alt="disable toc number"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装-Hexo&quot;&gt;&lt;a href=&quot;#安装-Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装 Hexo&quot;&gt;&lt;/a&gt;安装 Hexo&lt;/h1&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Hexo" scheme="https://zh-wiki.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令</title>
    <link href="https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://zh-wiki.github.io/undefined/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux%20%E5%91%BD%E4%BB%A4/Git%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2019-12-31T16:00:01.000Z</published>
    <updated>2021-01-30T08:33:26.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><ol><li><p>所有的命令输出在同一页显示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.pager <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="撤销指令"><a href="#撤销指令" class="headerlink" title="撤销指令"></a>撤销指令</h1><ol><li>撤销工作区的修改<br> <strong>git checkout</strong> 文件名<br> <strong>git checkout</strong> 目录 -f</li><li>从暂存区撤销到工作区（可以理解为<strong>git add</strong>的反向动作）<br> <strong>git reset HEAD</strong></li><li>从版本库撤销到暂存区<br> <strong>git reset –soft HEAD^</strong></li><li>从版本库撤销到工作区<br> <strong>git reset –mixed HEAD^</strong></li><li>撤销到上一次提交（本地修改丢失）<br> <strong>git reset –hard HEAD^</strong></li></ol><h1 id="保存恢复指令"><a href="#保存恢复指令" class="headerlink" title="保存恢复指令"></a>保存恢复指令</h1><ol><li>保存本地未追踪的修改<br>  <strong>git stash save</strong> 路径</li><li>将保存的内容导出<br> <strong>git stash pop stash@{index}</strong></li><li>获取保存列表<br>  <strong>git stash list</strong></li></ol><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p>这里我分为两种情况：</p><ol><li><p>代码提到服务器上。<br> a. 首先把自己的提交reset掉。<br> b.更新代码<br> c.将自己的代码从服务器上拉下来。<br> d.冲突用code工具解决掉。然后add 修改文件，重新commit</p></li><li><p>代码在本地提交<br> a.将本地提交撤回到工作区。<br> b.保存本地修改<br> c.更新代码<br> d.将保存的代码还原。<br> e.冲突用code工具解决掉。然后add 修改文件，重新commit</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本配置&quot;&gt;&lt;a href=&quot;#基本配置&quot; class=&quot;headerlink&quot; title=&quot;基本配置&quot;&gt;&lt;/a&gt;基本配置&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;所有的命令输出在同一页显示&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;tab</summary>
      
    
    
    
    <category term="技术研发" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"/>
    
    <category term="Linux 命令" scheme="https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"/>
    
    
    <category term="Linux 命令" scheme="https://zh-wiki.github.io/tags/Linux-%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
