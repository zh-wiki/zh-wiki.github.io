{"pages":[{"title":"Categories","date":"2021-01-30T08:33:26.291Z","path":"categories/index.html","text":""},{"title":"About","date":"2021-01-30T08:33:26.291Z","path":"about/index.html","text":"姓名： 周俊威 年龄： 正当年少 工作： IT攻城狮 理想： 实现所有吹出去的牛逼"},{"title":"Tags","date":"2021-01-30T08:33:26.291Z","path":"tags/index.html","text":""}],"posts":[{"title":"Welcome Zhou jun wei's Wiki Site","date":"2021-01-30T08:33:17.763Z","path":"undefined/index/","text":"","tags":[],"categories":[]},{"title":"图片数据格式与转换","date":"2021-01-21T01:52:03.000Z","path":"undefined/技术研发/Camera 专业知识/图片数据格式与转换/","text":"Camera Sensor 数据格式 Sensor 出图简介外部光线穿过lens后，经过color filter滤波后照射到Sensor面上， Sensor将从lens上传导过来的光线转换为电信号，再通过内部的DA转换为数字信号。 如果sensor内部集成ISP, 那么sensor可以直接生成支持的格式，如 YUV , JPEG ,RGB 。 如果Sensor没有集成ISP，则传输到baseband（基带=未经处理的电信号），此时的数据格式是RAW RGB data。 综上所述sensor出图支持以下格式 .tg {border-collapse:collapse;border-color:#ccc;border-spacing:0;} .tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-baqh{text-align:center;vertical-align:top} .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top} .tg .tg-0lax{text-align:left;vertical-align:top} 数据格式 描述 RAW RGB luma (Y) + chroma (UV) 格式， 一般情况下sensor支持YUV422格式，即数据格式是按Y-U-Y-V次序输出的 RGB 传统的红绿蓝格式，比如RGB565，其16-bit数据格式为5-bit R + 6-bit G + 5-bit B。G多一位，原因是人眼对绿色比较敏感。 YUV sensor的每一像素对应一个彩色滤光片，滤光片按Bayer pattern分布。将每一个像素的数据直接输出，即RAW RGB data JPEG 有些sensor，特别是低分辨率的，其自带JPEG engine，可以直接输出压缩后的jpg格式的数据 RAW RGB 数据格式通过上面的介绍，可以指导 raw RGB 是通过内部的DA转换为数字信号。因为sensor上每个像素只采集特定颜色的光的强度，因此sensor每个像素只能为R或G或B，形成的数据就成为了rawRGB数据。 rawRGB数据是sensor的经过光电转换后通过ADC采样后直接输出数据，是未经处理过的数据，表示sensor接受到的各种光的强度。 rawRGB数据排列格式有四种 由上图可以看出，每一种格式的rawRGB数据的G分量都是B、R分量的两倍，是因为人眼对于绿色的更加敏感，所以加重了其在感光点的权重，增加了对绿色信息的采样。 RGB 数据格式 在数字化的时代，需要一种标准来量化自然界的各种颜色。RGB就是一种在数字化领域表示颜色的标准，也称作一种色彩空间，通过用三原色R、G、B的不同的亮度值组合来表示某一种具体的颜色。 注意：RGB里面存的是颜色的亮度值，而不是色度值 目前人类发明的所有彩色的输入输出设备，本质上都只支持RGB数据。哪怕设备允许YUV的输入输出，那也是经过内部的数据转换而间接支持。 常用的RGB格式如下表所示 .tg {border-collapse:collapse;border-color:#ccc;border-spacing:0;} .tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-baqh{text-align:center;vertical-align:top} .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top} .tg .tg-0lax{text-align:left;vertical-align:top} 格式 描述 RGB565 每个像素用16位表示，RGB分量分别使用5位、6位、5位（常用也就是上说的RGB） RGB555 每个像素用16位表示，RGB分量都使用5位（剩下1位不用） RGB888 每个像素用24位表示，RGB分量各使用8位 RGB32 每个像素用32位表示，RGB分量各使用8位（剩下8位不用） ARGB32 每个像素用32位表示，RGB分量各使用8位（剩下的8位用于表示Alpha通道值）。 YUV 数据格式YUV 的基本概念以及作用 YUV 的基本介绍 YUV是一种色彩编码方法，Y表示亮度，U和V表示色度。只有Y就是黑白图像，再加上UV就是彩色图像了。YUV的一个好处就是让彩色系统和传统黑白系统很好的兼容，同时利用了人类视觉系统对亮度的敏感度比对色度高。 在一般应用中，人们所说的YUV就是YCbCr，常见应用如H.264/H.265码流、MPEG、JPEG等。 YCbCr中的Cb指蓝色色度分量，而Cr指红色色度分量。 YUV和RGB的相同点：都是用来表达颜色的数学方法； YUV和RGB的不同点：对颜色的描述思路和方法不同。RGB将一个颜色拆解为3个纯色的亮度组合，YUV将一个颜色分解为一个亮度和2个色度的组合。 为什么要有yuv，作用是什么 YUV提取Y亮度信号，可以直接给黑白电视使用，兼容黑白电视 人眼对UV的敏感性小于亮度，这样我们适当减少uv的量，而不影响人的感官。所以才会有多种格式的 YUV描述，如420、422、444。 YUV格式可以比RGB格式储存空间小。 YUV 的采样格式 .tg {border-collapse:collapse;border-color:#ccc;border-spacing:0;} .tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle} .tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top} .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 采样方式 描述 YUV 4:4:4 采样 全采样，对每个像素点的的YUV分量都进行采样，这样的三个分量信息量完整。 YUV 4:2:2 采样 部分采样，可节省1/3存储空间和1/3的数据传输量。UV分量是Y分量采样的一半，Y分量和UV 分量按照2 : 1的比例采样。每采样过一个像素点，都会采样其Y分量，而U、V分量就会间隔一个采集一个。 YUV 4:2:0 采样 部分采样，可节省1/2存储空间和1/2的数据传输量。YUV 420采样，并不是指只采样U分量而不采样V分量。在每一行扫描时，只扫描一种色度分量（U或者V），和Y分量按照2 : 1的方式采样。比如，第一行扫描时，YU 按照 2 : 1的方式采样，那么第二行扫描时，YV分量按照 2:1的方式采样。对于每个色度分量来说，它的水平方向和竖直方向的采样和Y分量相比都是2:1 。 YUV 的存储格式 YUV存储格式通常有两大类：打包（packed）格式和平面（planar）格式。前者将YUV分量存放在同一个数组中，通常是几个相邻的像素组成一个宏像素(macro-pixel)；而后者使用三个数组分开放 YUV 三个分量，就像是一个三维平面一样。 YUV422 Planar (YUV422P 也称为I422) 这里，Y\\U\\V数据是分开存放的，每两个水平Y采样点，有一个U和一个V采样点，如下 采用的是平面格式进行存储，先存储所有的 Y 分量，再存储所有的 U 分量，再存储所有的 V 分量 假如一个8*2像素的图像的该格式的存储分布如下图： YuV422 packed 此格式有两种情况：分为YUYV格式和UYVY格式 ① YUYV 格式 ​ YUYV 格式是采用打包格式进行存储的，指每个像素点都采用 Y 分量，但是每隔一个像素采样它的UV分量。 ​ 假如一个8*2像素的图像的该格式的存储分布如下图： ​ ② UYVY 格式 ​ UYVY 格式也是采用打包格式进行存储，它的顺序和YUYV相反，先采用U分量再采样Y分量。 ​ 假如一个8*2像素的图像的该格式的存储分布如下图： ​ YUV420 Planar (YUV420P) 这个格式跟YUV422 Planar 类似，但对于U和V的采样在水平和垂直方向都减少为2:1，根据采样规则如下 针对与 YUV420 Planar 这种格式又分为两种格式 YU12 （也称为I420格式） 是先Y再U后V。 YV12是先Y再V后U YUV422 Semi-Planar (YUV422SP) Semi 是“半”的意思，个人理解这个是半平面模式，这个格式的数据量跟YUV422 Planar的一样，但是U、V是交叉存放的。 YUV420 Semi-Planar (YUV420SP) 这个格式的数据量跟YUV420 Planar的一样，但是U、V是交叉存放的。 NV12和NV21格式都属于 YUV420SP 类型。它也是先存储了Y分量，但接下来并不是再存储所有的U或者V分量，而是把UV分量交替连续存储。 NV12是IOS中有的模式，它的存储顺序是先存Y分量，再UV进行交替存储。 NV21是安卓中有的模式，它的存储顺序是先存Y分量，在VU交替存储。 RGB 与 YUV的转换 参考文献 https://blog.csdn.net/qq_29575685/article/details/103954096","tags":[{"name":"Camera","slug":"Camera","permalink":"https://zh-wiki.github.io/tags/Camera/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera 专业知识","slug":"技术研发/Camera-专业知识","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"自动对焦专讲","date":"2021-01-21T01:52:02.000Z","path":"undefined/技术研发/Camera 专业知识/自动对焦/","text":"自动对焦的工作原理 AF的对焦原理是通过电磁感应使镜头移动，改变焦距完成自动对焦。 VCM 实现对焦原理 进入自动对焦（AF）模式后，Driver IC输出电流从0到最大值，使得镜头从原始位置移动到最大位置，此时ISP通过sensor成像，计算每一副图片的MTF（Modulation transfer function）值，从而在这条MTF曲线中找到最大值（即图像最清晰的点），并通过算法，得到这个点对应的电流大小，再一次指示Driver IC提供给音圈这个电流，而使镜头稳定在这个成像面，达到自动变焦效果。 AF的目的是确定实现对焦的最佳镜头位置，并触发VCM将镜头移动到该位置。一般来说，AF过程如下： AF算法同时检测硬件和软件统计数据，以确定是否存在场景变化。 如果算法检测到场景变化，则算法触发搜索。 算法的粗搜索确定下一个镜头位置。 VCM逐渐将镜头移动到下一个位置。 精搜索找到最终的镜头位置。 VCM将镜头移动到最终位置。 AF对焦方式分为：对比度/反差对焦(CAF)、相位对焦(PDAF)、激光对焦(TOFAF)，每种算法都实现了检测和搜索功能。 反差对焦 CAF对比度对焦，也叫反差对焦。反差对焦是目前普及率最高，使用最广泛，成本相对较低的自动对焦技术。对焦的过程就是通过移动镜片来使对焦区域的图像达到最清晰的过程，所以对焦成功以后，直观的感受就是焦点的清晰度最高，而焦点以外的区域则表现为相对模糊状态。因为反差对焦的工作方式是进行对比度检测，因此相机镜片必须要前后移动完整记录所有的图像信息，然后计算出对比度最高的位置，才能最终完成对焦，所以反差对焦的一个主要缺点就是耗费的时间较长。 相位差对焦 PDAFPDAF 工作原理在CMOS（感光元件）上留出一些成对儿的遮蔽像素点来进行相位检测，即从像素传感器上拿出左右相对的成对像素点，分别对场景中的物体进行进光量等信息的检测，通过比对左右两侧的相关值情况，对焦系统根据判断信号波峰的位置可判断出镜头应该往前还是往后偏移，便会迅速找出准确的对焦点，之后镜间马达便会一次性将镜片推动到相应位置完成对焦。位对焦也并不是十分完美，它对光线的要求就比较高，在弱光拍摄环境下，相位对焦就无能为力了。 上图中，紫色是物体的一个点，黄色是sensor即成像面 1号蓝色镜片离sensor太远，上下两条光线所成的像没有重合； 2号蓝色镜片和snesor的距离合适，上下两条光线所成的像重合了没有相差，所以对焦成功； 3、4号蓝色镜片离sensor的距离太近了，上下两条光线所成的像没有重合，但是和1号不同的是相差的方向是不一样的。 通过计算相位差并将其转换为defocus(离焦)值，以指示实现聚焦所需的镜头移动的大小和方向。正defocus值意味着运动由近到远，负defocus值意味着运动从远到近。当defocus值接近零时，表示目标处于焦点。 PD 值与 lens 位移的转换系统在进行对焦的时候，需要将检测到的相位差(phase difference)转换为离焦率(Defocus Value)，这个转换过程应用到的表单数据称为DCC(defocus conversion coefficient)离焦转换系数 基于camx架构的pdaf bringuppdaf bringup 需要配置的文件 pdaf 配置文件 12345678910111213141516171819202122232425262728#\\vendor\\qcom\\proprietary\\chi-cdk\\oem\\qcom\\sensor\\lime_sunny_s5kgm1st_main\\xxx_pdaf.xml#这个pdaf驱动文件由fae提供，相关参数含义如下：&lt;/PDAFName&gt;//pdaf名字&lt;/PDOrientation&gt; //pdaf像素方向&lt;/PDDefocusConfidenceThreshold&gt; //触发pdaf的阈值，默认200&lt;/PDBlackLevel&gt; //黑电平，默认64&lt;/PDSensorMode&gt; //对应哪一组sensor setting，配置1对应第2组setting&lt;/PDType&gt; //PD类型，datasheet或问FAE&lt;/PDNativeBufferFormat&gt; //PD传输格式&lt;/PDBlockCountHorizontal&gt; //PD 水平Block的个数，新平台按照16*16分块&lt;/PDBlockCountVertical&gt; //PD 垂直Block的个数，新平台按照16*16分块&lt;/PDPixelCount&gt; //每个块中PD像素点个数&lt;/PDXCoordinate&gt; //第一块中PD像素点的x坐标(绝对坐标，代码中会减去PDOffsetHorizontal)&lt;/PDYCoordinate&gt; //第一块中PD像素点的y坐标(绝对坐标，代码中会减去PDOffsetHorizontal)&lt;PDBlockDimensions&gt; //每个块宽高，新平台按照16*16分块&lt;/PDOffsetHorizontal&gt; //第一块的x偏移量&lt;/PDOffsetHorizontal&gt; //第一块的y偏移量&lt;PDCropRegion&gt; //sensor full size尺寸&lt;/PDDownscaleFactorHorizontal&gt; //当前sensor尺寸的x Downscale&lt;/PDDownscaleFactorVertical&gt; //当前sensor尺寸的y Downscale&lt;/PDStride&gt; //PDBlockCountHorizontal×每个block中x的pd点个数（l和r）×2&lt;/PDBufferFormat&gt; &lt;/PDPixelCount&gt; //第一块PD中的PD点个数&lt;/PDXCoordinate&gt; //第一块中PD点x在buffer中的坐标&lt;/PDYCoordinate&gt; //第一块中PD点y在buffer中的坐标&lt;PDBlockDimensions&gt; //每一块中PD点在buffer的宽高&lt;/PDOffsetHorizontal&gt; //每一块中PD点在buffer的x偏移&lt;/PDOffsetVertical&gt; //每一块中PD点在buffer的y偏移 sensor 配置文件 12345678910111213141516#### \\vendor\\qcom\\proprietary\\chi-cdk\\oem\\qcom\\sensor\\lime_sunny_s5kgm1st_main\\xxx_sensor.xml#在对应的sensor setting中添加PD像素配置：&lt;streamConfiguration&gt;&lt;vc range=&quot;[0,3]&quot;&gt;1&lt;/vc&gt;//virtual chennel，查阅datasheet&lt;dt&gt;0x2b&lt;/dt&gt;//mipi data type，setting说明中&lt;frameDimension&gt;&lt;xStart&gt;0&lt;/xStart&gt;&lt;yStart&gt;0&lt;/yStart&gt;&lt;width&gt;992&lt;/width&gt;//x方向的PD点个数&lt;height&gt;748&lt;/height&gt;//y方向的PD点个数&lt;/frameDimension&gt;&lt;bitWidth&gt;10&lt;/bitWidth&gt;//位宽&lt;type&gt;PDAF&lt;/type&gt;//类型&lt;/streamConfiguration&gt;#注意：此配置只有在pdaf类型为type2的时候需要，type3类型的pd无需在sensor xml中配置 module 配置文件 12#\\vendor\\qcom\\proprietary\\chi-cdk\\oem\\qcom\\module\\xxx_module.xml&lt;/pdafName&gt;//pdaf name,与xxx_pdaf.xml中的一致 yaml 配置文件 1234#\\vendor\\qcom\\proprietary\\chi-cdk\\tools\\buildbins\\xxx.yamlsensor_drivers:- com.qti.sensormodule.lime_sunny_s5kgm1st_main: - sensor/lime_sunny_s5kgm1st_main/lime_sunny_s5kgm1st_main_pdaf.xml 平台配置文件 12345678910#vendor/qcom/proprietary/camx/src/settings/common/camxsettings.xml &lt;setting&gt;is_stable=TRUELine 1001836: 01-03 07:11:53.503 681 4760 D mm-camera&lt;Name&gt;Disable PDAF&lt;/Name&gt; &lt;Help&gt;Completely disable PDAF&lt;/Help&gt;&lt;VariableName&gt;disablePDAF&lt;/VariableName&gt;&lt;VariableType&gt;BOOL&lt;/VariableType&gt;&lt;SetpropKey&gt;persist.vendor.camera.disablePDAF&lt;/SetpropKey&gt;&lt;DefaultValue&gt;FALSE&lt;/DefaultValue&gt;&lt;Dynamic&gt;TRUE&lt;/Dynamic&gt; check persist.vendor.camera.disablePDAF是否为false;如果为true，则需 adb shell setprop persist.vendor.camera.disablePDAF FALSE 123#vendor/qcom/proprietary/chi-cdk/oem/qcom/tuning/lime_sunny_s5kgm1st_main_c7project/Scenario.Default/XML/STATS/chromatixHAF.xml check下 &lt;PDAFEnable&gt;1&lt;/PDAFEnable&gt;这一项要置1 pdaf debug更新xxx_sensor.bin文件后，打开debug log: adb shell “echo afFullsweep=3&gt;&gt; /vendor/etc/camera/camxoverridesettings.txt”adb shell “echo logVerboseMask=0x8000202 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt”adb shell “echo logInfoMask=0x8000202 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt” 重启后打开摄像头，焦距范围内对着黑白条纹纸张拍摄，此时AF会跑Fullsweep的代码，检索关键字 adb logcat | grep “af_pdaf_proc_pd_single roi(0) lens_pos” &gt; fullsweep.txt 其中lens_pos增大时，defocus(um)减小；lens_pos减小时，defocus(um)增大，且相加几乎是一个恒定值。而且conf的数值在1023左右。选择lens_pos 和pd两项数值做成折线图 能清晰的看到lens_pos 和pd是成线性关系的，且能看到pd =0是有相应的len_pos值，则pdaf应该就没什么问题了 高通MM架构 PDAF 调试方法 首先设置号相应的log权限 12adb shell setprop persist.camera.stats.af.debug 5adb shell setprop persist.camera.stats.haf.debug 5 使相机进入fullsweep(全扫描)模式 1adb shell setprop vendor.debug.camera.af_fullsweep 1 可能不同的平台命令有所不同，可以在代码中搜索 123456789101112//vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/stats/q3a/af/af_biz.cvoid af_biz_process(stats_af_t *stats, af_output_data_t *output, uint8_t num_of_outputs, void *af_obj) &#123; // Get Setproc for fullsweep algo. /* Enable full-sweep property: * 0 - disable * 1 - far-to-near * 2 - reverse search (near-to-far) * 3 - both (far-&gt;near-&gt;far)*/ property_get(&quot;vendor.debug.camera.af_fullsweep&quot;, value, &quot;0&quot;); &#125; log 分析 123456789101112Line 86657: 01-03 07:11:00.426 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=438 index=14, pd=-10.02, defocus(um)=-248, conf=537, is_conf=FALSE, not_conf_cnt=13, is_stable=TRUELine 88565: 01-03 07:11:00.504 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=438 index=16, pd=-10.24, defocus(um)=-253, conf=559, is_conf=FALSE, not_conf_cnt=15, is_stable=TRUELine 94865: 01-03 07:11:00.769 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=434 index=22, pd=-10.55, defocus(um)=-262, conf=532, is_conf=FALSE, not_conf_cnt=21, is_stable=TRUELine 98620: 01-03 07:11:00.905 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=432 index=26, pd=-10.45, defocus(um)=-259, conf=547, is_conf=FALSE, not_conf_cnt=25, is_stable=TRUE..................Line 692125: 01-03 07:11:35.301 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=4 index=34, pd=6.69, defocus(um)=166, conf=916, is_conf=FALSE, not_conf_cnt=259, is_stable=TRUELine 694909: 01-03 07:11:35.424 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=2 index=37, pd=6.72, defocus(um)=166, conf=917, is_conf=FALSE, not_conf_cnt=262, is_stable=TRUELine 697981: 01-03 07:11:35.661 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=0 index=43, pd=6.83, defocus(um)=169, conf=945, is_conf=FALSE, not_conf_cnt=268, is_stable=TRUE.................Line 1000442: 01-03 07:11:53.425 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=166 index=36, pd=-0.06, defocus(um)=-1, conf=705, is_conf=TRUE, not_conf_cnt=0, is_stable=TRUELine 1001078: 01-03 07:11:53.460 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=166 index=37, pd=0.05, defocus(um)=1, conf=695, is_conf=TRUE, not_conf_cnt=0, is_stable=TRUELine 1001836: 01-03 07:11:53.503 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=166 index=38, pd=0.15, defocus(um)=3, conf=731, is_conf=TRUE, not_conf_cnt=0, is_stable=TRUE 进入fullsweep Mode Far to Near 进行完一次全扫描后，lens position 最终是 166，观察pd值 和 defocus 接近于0 表示正常 过程中观察 pd 和 defocus 值应该是成线性的","tags":[{"name":"Camera","slug":"Camera","permalink":"https://zh-wiki.github.io/tags/Camera/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera 专业知识","slug":"技术研发/Camera-专业知识","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"Camera 成像原理和专业知识","date":"2021-01-21T01:52:01.000Z","path":"undefined/技术研发/Camera 专业知识/Camera 成像原理和专业知识/","text":"Camera 模组 基本介绍 一个camera主要由两部分组成，镜头(Lens)，感光IC(Sensor IC)。其中大部分的Sensor都是自己集成DSP的。 Sensor将Lens上传导过来的光线转换为电信号，通过CFA滤波后，变为三基色，再通过内部的DA转换为数字信号。对于CFA模式的相机来说，Sensor中的每个pixel只能感光R光/B光/G光，因此每个像素此时存贮的都是单色的。 一个camera的输出信号： 一般有data信号，输出YUV，RGB，JPEG格式的数据。 hsync信号，行同步信号，表示一个frame有效。 vsync信号，列同步信号，对于一个frame表示新的一行有效。 PCLK信号，每一个像素的同步时钟。 输出I2C总线，主要用在通信，寄存器配置。 彩色滤波阵列-CFA 图像传感器都采用一定的模式来采集图像数据，常用的有 RGB 模式和 CFA 模式。BGR 模式是一种可直接进行显示和压缩等处理的图像数据模式，它由 R( 红)、G( 绿) 、B( 蓝) 三原色值来共同确定 1 个像素点，例如富士数码相机采用的 SUPER CCD 图像传感器就采用这种模式，其优点是图像传感器产生的图像数据无需插值就可直接进行显示等后续处理，图像效果最好，但是成本高，常用于专业相机中。 为了减少成本，缩小体积，市场上的数码相机大多采用 CFA 模式，即在像素阵列的表面覆盖一层彩色滤波阵列（Color Filter Array，CFA），彩色滤波阵列有多种，现在应用最广泛的是 Bayer 格式滤波阵列，满足 GRBG 规律，绿色像素数是红色或蓝色像素数的两倍，这是因为人眼对可见光光谱敏感度的峰值位于中波段，这正好对应着绿色光谱成分。在该模式下图像数据只用R, G, B三个值中的一个值来表示一个像素点，而缺失另外两个颜色值，这时得到的是一副马赛克图片，为了得到全彩色的图像，需要使用其周围像素点的色彩信息来估计缺失的另外两种颜色，这种处理叫做色彩插值。 相位对焦 PDAF (Phase Detection Auto Focus) 简介 在CMOS（感光元件）上留出一些成对儿的遮蔽像素点来进行相位检测，即从像素传感器上拿出左右相对的成对像素点，分别对场景中的物体进行进光量等信息的检测，通过比对左右两侧的相关值情况，对焦系统根据判断信号波峰的位置可判断出镜头应该往前还是往后偏移，便会迅速找出准确的对焦点，之后镜间马达便会一次性将镜片推动到相应位置完成对焦。 对焦的基本过程 通过左右(屏蔽像素点)shield pixel之间的差异来将被摄物映射到镜头移动距离中的某个位置。 系统在进行对焦的时候，需要将检测到的相位差(phase difference)转换为离焦率(Defocus Value)，这个转换过程应用到的表单数据称为DCC(defocus conversion coefficient)离焦转换系数。 Camera 尺寸相关 我们在追Camera configureStream 流程的时候一般会看到以下关键字 123HAL_PIXEL_FORMAT_BLOB = 33;HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED = 34;HAL_PIXEL_FORMAT_YCbCr_420_888 = 35; HAL_PIXEL_FORMAT_BLOB表示是jpeg stream，对应的size即平时所说的picture size HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED表示preview stream，对应的size即平时所说的preview size.","tags":[{"name":"Camera","slug":"Camera","permalink":"https://zh-wiki.github.io/tags/Camera/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera 专业知识","slug":"技术研发/Camera-专业知识","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"camera 基础知识","date":"2021-01-21T01:52:00.000Z","path":"undefined/技术研发/Camera 专业知识/camea基础知识/","text":"CMOS Sensor 简介 Color Science 光学基础 图像信号处理 3A系统概述 黑电平与线性化 Green Imbalence 坏点消除 Lens Shading Raw Denosie Dynamic Range And Tone Demosaic Color Reporoduciton Color Correction Gamma与对比度增强 Sharpening Color Space Matrix Spatial Denoise Temor Depurple ISP 统计信息 自动曝光 自动白平衡 自动对焦 闪光灯 HDR 文件格式 Encoder 上集 下集 图像防抖 图像质量评价工具与方法 画质调优 双摄及景深计算 成像系统仿真 结构光 TOF 概述","tags":[{"name":"camera基础知识","slug":"camera基础知识","permalink":"https://zh-wiki.github.io/tags/camera%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera 专业知识","slug":"技术研发/Camera-专业知识","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"}]},{"title":"ITS 测试案例分析","date":"2020-12-31T16:00:01.000Z","path":"undefined/技术研发/XTS 相关/ITS 问题案例分析/","text":"scene1_2 test_yuv_plus_raw10.py 该case主要是测试什么？ 通过测试脚本应该是测试","tags":[{"name":"XTS","slug":"XTS","permalink":"https://zh-wiki.github.io/tags/XTS/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"XTS 相关","slug":"技术研发/XTS-相关","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/XTS-%E7%9B%B8%E5%85%B3/"}]},{"title":"生活学习","date":"2020-10-04T08:22:36.000Z","path":"undefined/生活学习/生活学习/","text":"","tags":[],"categories":[{"name":"生活学习","slug":"生活学习","permalink":"https://zh-wiki.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"}]},{"title":"艺术","date":"2020-10-04T08:22:36.000Z","path":"undefined/艺术/艺术/","text":"","tags":[],"categories":[{"name":"艺术","slug":"艺术","permalink":"https://zh-wiki.github.io/categories/%E8%89%BA%E6%9C%AF/"}]},{"title":"UML","date":"2020-09-29T15:23:24.000Z","path":"undefined/程序语言/UML/UML/","text":"","tags":[{"name":"UML","slug":"UML","permalink":"https://zh-wiki.github.io/tags/UML/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"UML","slug":"程序语言/UML","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/"}]},{"title":"高通 Camx Bring up","date":"2019-12-31T16:00:30.000Z","path":"undefined/技术研发/Camera Driver/高通 Camx/高通 Camx Bring up/","text":"Bring Up SensorHAL层的配置 移植驱动代码到相应的路径 vendor/qcom/proprietary/chi-cdk/oem/qcom/sensor/ 驱动文件名字根据项目而定 sensor xml 相关配置 lime_sunny_hi259_macro_sensor.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;slaveInfo&gt; &lt;!--Name of the sensor --&gt; &lt;sensorName&gt;lime_sunny_hi259_macro&lt;/sensorName&gt; &lt;!--8-bit or 10-bit write slave address For External Sensors for which camx needs not probe the slave address shoule be as 0 --&gt; &lt;slaveAddress&gt;0x60&lt;/slaveAddress&gt; &lt;!--Register address / data size in bytes --&gt; &lt;regAddrType range=&quot;[1,4]&quot;&gt;2&lt;/regAddrType&gt; &lt;!--Register address / data size in bytes --&gt; &lt;regDataType range=&quot;[1,4]&quot;&gt;2&lt;/regDataType&gt; &lt;!--Register address for sensor Id --&gt; &lt;sensorIdRegAddr&gt;0x04&lt;/sensorIdRegAddr&gt; &lt;!--Sensor Id 0xE1--&gt; &lt;sensorId&gt;0x113&lt;/sensorId&gt; &lt;!--Mask for sensor id. Sensor Id may only be few bits --&gt; &lt;sensorIdMask&gt;4294967295&lt;/sensorIdMask&gt; &lt;!--I2C frequency mode of slave Supported modes are: STANDARD (100 KHz), FAST (400 KHz), FAST_PLUS (1 MHz), CUSTOM (Custom frequency in DTSI) --&gt; &lt;i2cFrequencyMode&gt;FAST&lt;/i2cFrequencyMode&gt; &lt;!--Sequence of power configuration type and configuration value required to control power to the device --&gt; &lt;powerUpSequence&gt; &lt;powerSetting&gt; &lt;configType&gt;RESET&lt;/configType&gt; &lt;configValue&gt;1&lt;/configValue&gt; &lt;delayMs&gt;1&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;CUSTOM_GPIO1&lt;/configType&gt; &lt;configValue&gt;1&lt;/configValue&gt; &lt;delayMs&gt;0&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;CUSTOM_GPIO2&lt;/configType&gt; &lt;configValue&gt;1&lt;/configValue&gt; &lt;delayMs&gt;2&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;MCLK&lt;/configType&gt; &lt;configValue&gt;24000000&lt;/configValue&gt; &lt;delayMs&gt;8&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;RESET&lt;/configType&gt; &lt;configValue&gt;0&lt;/configValue&gt; &lt;delayMs&gt;1&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;/powerUpSequence&gt; &lt;!--Sequence of power configuration type and configuration value required to control power to the device --&gt; &lt;powerDownSequence&gt; &lt;!--Power setting configuration Contains: configType, configValue and delay in milli seconds --&gt; &lt;powerSetting&gt; &lt;configType&gt;RESET&lt;/configType&gt; &lt;configValue&gt;1&lt;/configValue&gt; &lt;delayMs&gt;1&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;MCLK&lt;/configType&gt; &lt;configValue&gt;0&lt;/configValue&gt; &lt;delayMs&gt;0&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;CUSTOM_GPIO1&lt;/configType&gt; &lt;configValue&gt;0&lt;/configValue&gt; &lt;delayMs&gt;0&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;powerSetting&gt; &lt;configType&gt;CUSTOM_GPIO2&lt;/configType&gt; &lt;configValue&gt;0&lt;/configValue&gt; &lt;delayMs&gt;1&lt;/delayMs&gt; &lt;/powerSetting&gt; &lt;/powerDownSequence&gt; &lt;/slaveInfo&gt; sensor name 跟sensor 文件夹名字一致 slaveAddress IIC 从机地址 sensor id 寄存器地址 以及 sensor id 上下电时序 (为了保险首先将reset引脚设置为禁止状态) module xml 配置 lime_sunny_hi259_macro_module.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;!--========================================================================--&gt;&lt;!-- Copyright (c) 2018 Qualcomm Technologies, Inc. --&gt;&lt;!-- All Rights Reserved. --&gt;&lt;!-- Confidential and Proprietary - Qualcomm Technologies, Inc. --&gt;&lt;!--========================================================================--&gt;&lt;cameraModuleData xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;..\\..\\..\\api\\sensor\\camxmoduleconfig.xsd&quot;&gt; &lt;module_version major_revision=&quot;1&quot; minor_revision=&quot;0&quot; incr_revision=&quot;0&quot;/&gt; &lt;!--Module group can contain either 1 module or 2 modules Dual camera, stereo camera use cases contain 2 modules in the group --&gt; &lt;moduleGroup&gt; &lt;!--Module configuration --&gt; &lt;moduleConfiguration description=&quot;Module configuration&quot;&gt; &lt;!--CameraId is the id to which DTSI node is mapped. Typically CameraId is the slot Id for non combo mode. --&gt; &lt;cameraId&gt;3&lt;/cameraId&gt; &lt;!--Name of the module integrator --&gt; &lt;moduleName&gt;sunny&lt;/moduleName&gt; &lt;!--Name of the sensor in the image sensor module --&gt; &lt;sensorName&gt;lime_sunny_hi259_macro&lt;/sensorName&gt; &lt;!--Actuator name in the image sensor module This is an optional element. Skip this element if actuator is not present --&gt; &lt;actuatorName&gt;&lt;/actuatorName&gt; &lt;oisName&gt;&lt;/oisName&gt; &lt;!--EEPROM name in the image sensor module This is an optional element. Skip this element if EEPROM is not present --&gt; &lt;eepromName&gt;&lt;/eepromName&gt; &lt;!--Flash name is used to used to open binary. Binary name is of form flashName_flash.bin Ex:- pmic_flash.bin --&gt; &lt;flashName&gt;&lt;/flashName&gt; &lt;!--Chromatix name is used to used to open binary. Binary name is of the form sensor_model_chromatix.bin --&gt; &lt;chromatixName&gt;lime_sunny_hi259_macro&lt;/chromatixName&gt; &lt;!--Position of the sensor module. Valid values are: REAR, FRONT, REAR_AUX, FRONT_AUX, EXTERNAL --&gt; &lt;position&gt;REAR_AUX&lt;/position&gt; &lt;!--CSI Information --&gt; &lt;CSIInfo description=&quot;CSI Information&quot;&gt; &lt;laneAssign&gt;2&lt;/laneAssign&gt; &lt;isComboMode&gt;1&lt;/isComboMode&gt; &lt;/CSIInfo&gt; &lt;!--Lens information --&gt; &lt;lensInfo description=&quot;Lens Information&quot;&gt; &lt;!--Focal length of the lens in millimeters. --&gt; &lt;focalLength&gt;4.71&lt;/focalLength&gt; &lt;!--F-Number of the optical system. --&gt; &lt;fNumber&gt;1.79&lt;/fNumber&gt; &lt;!--Minimum focus distance in meters. --&gt; &lt;minFocusDistance&gt;0.1&lt;/minFocusDistance&gt; &lt;!--Total focus distance in meters. --&gt; &lt;maxFocusDistance&gt;1.9&lt;/maxFocusDistance&gt; &lt;!--Horizontal view angle in degrees. --&gt; &lt;horizontalViewAngle&gt;67&lt;/horizontalViewAngle&gt; &lt;!--Vertical view angle in degrees. --&gt; &lt;verticalViewAngle&gt;53&lt;/verticalViewAngle&gt; &lt;!--Maximum Roll Degree. Valid values are: 0, 90, 180, 270, 360 --&gt; &lt;maxRollDegree&gt;270&lt;/maxRollDegree&gt; &lt;!--Maximum Pitch Degree. Valid values are: 0 to 359 --&gt; &lt;maxPitchDegree&gt;360&lt;/maxPitchDegree&gt; &lt;!--Maximum Yaw Degree. Valid values are: 0 to 359 --&gt; &lt;maxYawDegree&gt;360&lt;/maxYawDegree&gt; &lt;/lensInfo&gt; &lt;pdafName&gt;&lt;/pdafName&gt; &lt;/moduleConfiguration&gt; &lt;/moduleGroup&gt;&lt;/cameraModuleData&gt; 配置 CameraId 与kernel dts 相对应 配置sensorname 与 sensor xml 保持一致 配置 chromatixName 与 sensor name 保持一致 配置 position 摄像头位置 前摄 后摄 或者 后辅 配置 CSIInfo mipi 通道 双摄帧同步导通 将camx平台默认的几个属性开启 12345678 //camxsettings.xml &lt;VariableName&gt;multiCameraEnable&lt;/VariableName&gt;&lt;VariableName&gt;multiCameraHWSyncMask&lt;/VariableName&gt;&lt;VariableName&gt;multiCameraFrameSyncMask&lt;/VariableName&gt;&lt;VariableName&gt;multiCameraFPSMatchMask&lt;/VariableName&gt;//高通的case还给了这两个，j19S项目代码中没有找到这连个配置，没有配置也是OK的adb shell &quot;echo multiCamera3ASync=QTI &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot;adb shell &quot;echo multiCameraSATEnable=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot; 在Camera Id 映射的位置指定双摄的Camera Id 12345678910static LogicalCameraConfiguration logicalCameraConfigurationKamorta[] =&#123; /*cameraId cameraType exposeFlag phyDevCnt sensorId, transition low, high, smoothZoom, alwaysOn realtimeEngine primarySensorID, hwMaster*/ &#123;0, LogicalCameraType_Default, TRUE, 1, &#123;&#123;0, 0.0, 0.0, FALSE, TRUE, RealtimeEngineType_IFE&#125;&#125;, 0, 0 &#125;, ///&lt; Wide camera &#123;1, LogicalCameraType_Default, TRUE, 1, &#123;&#123;2, 0.0, 0.0, FALSE, TRUE, RealtimeEngineType_IFE&#125;&#125;, 2, 2 &#125;, ///&lt; Front camera &#123;2, LogicalCameraType_Default, TRUE, 1, &#123;&#123;1, 0.0, 0.0, FALSE, TRUE, RealtimeEngineType_IFE&#125;&#125;, 1, 1 &#125;, ///&lt; Tele camera &#123;3, LogicalCameraType_Default, TRUE, 1, &#123;&#123;3, 0.0, 0.0, FALSE, TRUE, RealtimeEngineType_IFE&#125;&#125;, 3, 3 &#125;, &#123;4, LogicalCameraType_RTB, TRUE, 2, &#123;&#123;0, 2.0, 8.0, FALSE, TRUE, RealtimeEngineType_IFE&#125;, &#123;2, 1.0, 2.0, FALSE, TRUE, RealtimeEngineType_IFE&#125;&#125;, 0, 0 &#125;, ///&lt; RTB&#125;; 在j19S项目中更改了一下参数 。（双摄预览出图是辐摄） 第一个参数: 调节zoom值 第二个参数: 配置主摄的camera Id 在j19S项目中还有存在一个平台bug （上面介绍的结构体双摄不能为最后一个成员） 高通给的patch 1234567891011121314151617//vendor/qcom/proprietary/chi-cdk / oem/qcom/feature2/chifeature2graphselector/chifeature2graphselector.cppVOID ChiFeature2GraphSelector::BuildCameraIdSet()&#123; //Add by junwei.zhou according Qcom case num 04763737 //fix platform design#ifdef __XIAOMI_CAMERA__ m_cameraIdMap.insert(&#123; &#123; cameraIdSetSingle &#125;, SINGLE_CAMERA &#125;); m_cameraIdMap.insert(&#123; &#123; cameraIdSetBokeh &#125;, BOKEH_CAMERA &#125;); m_cameraIdMap.insert(&#123; &#123; cameraIdSetMulti &#125;, MULTI_CAMERA &#125;); m_cameraIdMap.insert(&#123; &#123; cameraIdSetFusion &#125;, FUSION_CAMERA &#125;);#else m_cameraIdMap.insert(&#123; &#123; cameraIdSetSingle &#125;, SINGLE_CAMERA &#125;); m_cameraIdMap.insert(&#123; &#123; cameraIdSetMulti &#125;, MULTI_CAMERA &#125;); m_cameraIdMap.insert(&#123; &#123; cameraIdSetBokeh &#125;, BOKEH_CAMERA &#125;); m_cameraIdMap.insert(&#123; &#123; cameraIdSetFusion &#125;, FUSION_CAMERA &#125;);#endif&#125; 分别配置主摄和辅摄的setting 主摄：masterSettings 辐摄：slaveSettings Dump EEprom Data1adb shell &quot;echo dumpSensorEEPROMData=1 &gt;&gt; /vendor/etc/camera/camxoverridesettings.txt&quot; 数据存放位置： /data/vendor/camera/xxx_kbuffer_OTP.txt","tags":[{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"}]},{"title":"高通 Camx capture result 代码流程","date":"2019-12-31T16:00:06.000Z","path":"undefined/技术研发/Camera Driver/高通 Camx/高通 Camx capture result 代码流程/","text":"预览和拍照的 result 代码流程","tags":[{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"}]},{"title":"高通 Camx capture request 代码流程","date":"2019-12-31T16:00:05.000Z","path":"undefined/技术研发/Camera Driver/高通 Camx/高通 Camx capture request 代码流程/","text":"预览和拍照的 request 代码流程主体框架图 详细代码调用流程123456789101112chi_override_process_request() //chxextensioninterface.cpp OverrideProcessRequest() //chxextensionmodule.cpp ProcessCaptureRequest()//chxusecase.cpp ExecuteCaptureRequest() //chxadvancedcamerausecase.cpp result = pFeature-&gt;ExecuteProcessRequest(pRequest); //会调到chifeature2wrapper.cpp:494 ExecuteProcessRequest() ExecuteProcessRequest() //chifeature2wrapper.cpp 开始进入算法的领域 SubmitRequestToSession() //经过一系类调用会走到 chifeature2base.cpp result = ExtensionModule::GetInstance()-&gt;ActivatePipeline() OnSubmitRequestToSession() ProcessFeatureMessage() ProcessMessageCb() //通过回调又重新回到 chifeature2wrapper.cpp result = pFeature2Wrapper-&gt;m_pUsecaseBase-&gt;SubmitRequest(&amp;submitRequest); //将 request 下到 camx session 中 CHI feature 通过 usecase 提交 request 到 session, 套路还是一样的（chxextensionmodule.cpp 通过这条链路转到Camx） 12result = pSession-&gt;ProcessCaptureRequest(pRequest); //camxchicontext.cpp feature submit request 会调到这里从这里开始步入 session CamxResult Session::ProcessCaptureRequest(); //camxsession.cpp","tags":[{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"}]},{"title":"高通 Camx config stream 代码流程","date":"2019-12-31T16:00:04.000Z","path":"undefined/技术研发/Camera Driver/高通 Camx/高通 Camx config stream 代码流程/","text":"","tags":[{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"}]},{"title":"Arch Linux 开发环境的搭建","date":"2019-12-31T16:00:03.000Z","path":"undefined/计算机基础知识/Arch Linux 开发环境的搭建/","text":"Arch Linux 系统安装 主要进行分区，系统的安装，图形服务和必要驱动的安装 分区 查看当前分区信息 1fdisk -l 设置分区 1cfdisk /dev/sda 1)首先选择分区类型 ​ MBR 选择 dos ​ GPT 选择 gpt 2)MBR启动一般分为2个分区 ​ 主分区 （选择为boot标志） ​ 交换分区（内存的2倍） 格式化分区 格式化主分区 1mkfs.ext4 /dev/sda1 格式化交换分区 1mkswap /dev/sda2 启动交换分区 1swapon /dev/sda2 挂载分区 1mount /dev/sda1 /mnt 编辑镜像源1vim /etc/pacman.d/mirrorlist 将中国的源放在文件的开头 安装系统基本组件1pacstrap /mnt base linux linux-firmware 安装基本开发工具包12arch-chroot /mntpacman -S base-devel 安装 sudo123arch-chroot /mntpacman -S sudo vi vimvisudo 删除这一行注释 %wheel ALL = (ALL) ALL 创建用户123arch-chroot /mntuseradd -G wheel -m 用户名passwad 用户名 安装 Grub1234arch-chroot /mntpacman -S grubgrub-install --target=i386-pc /dev/sdagrub-mkconfig -o /boot/grub/grub.cfg 生成 fstab该配置不需要 arch-chroot 1genfstab /mnt &gt; /mnt/etc/fstab 安装 Xorg 图形管理1pacstrap /mnt xorg-server xorg-xinit xorg-apps 安装网络组件12345pacstrap /mnt dhcpcd wpa_supplicant networkmanagerarch-chroot /mntsystemctl enable dhcpcdsystemctl enable wpa_supplicantsystemctl enable networkmanager 安装显卡驱动12lspci | grep VGA //查看显卡是什么型号pacman -S xf86-video-intel //intel 显卡驱动 安装音频组件12pacstrap /mnt alsa-utils pulseaudiopacstrap /mnt pulseaudio-alsa Arch Linux 桌面环境安装 窗口管理器 dwm 安装终端内置浏览器 w3m 1sudo pacman -S w3m 下载 dwm 1w3m suckless.org 安装 1sudo make clean install 运行dwm 12vim ~/.xinitrcstartx 在 .xinitrc 中 加入 exec dwm Arch Linux 基础配置 安装中文字体 12sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emojisudo vim /etc/locale.gen 取消 /etc/locale.gen 中 以下 的注释 en_US.UTF-8 UTF-8 zh_CN.UTF-8 UTF-8 zh_TW.UTF-8 UTF-8 生成 locale 1sudo locale-gen 设置 archlinuxcn123sudo vim /etc/pacman.confsudo pacman -Sysudo pacman -S archlinuxcn-keyring 在文件的末尾插入 [archlinuxcn] Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 安装 Chrome1sudo pacman -S google-chrome 安装中文输入法 安装输入法以及配置工具 1sudo pacman -S fcitx fcitx-im kcm-fcitx fcitx-qt5 fcitx-gtk2 fcitx-gtk3 fcitx-configtool 配置输入法 1vim ~/.xprofile 输入以下内容 export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=”@im=fcitx” SSH 的安装与配置 安装ssh 1pacman -Sy openssh 生成密钥 1ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot; 通过 SSH 远程连接问题 1vim /etc/ssh/sshd_config 在文件的末尾加以下配置 LoginGraceTime 120PermitRootLogin yesStrictModes yes vscode zsh 乱码 设置vscode终端字体","tags":[{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://zh-wiki.github.io/tags/Arch-Linux/"}],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"高通 Camx Camx open camera","date":"2019-12-31T16:00:03.000Z","path":"undefined/技术研发/Camera Driver/高通 Camx/高通 Camx open camera/","text":"Open Camera 的流程简介当用户打开了相机设备之后，便会发生如下过程： APP调用CameraManager的openCamera方法，层层调用之后最终调用到Camera Service层中的CameraService::connectDevice方法 然后通过ICameraDevice::open()这一个HIDL接口通知Camera Provider层 在Camera Provider层内部又通过调用之前获取的camera_module_t中methods的open方法来获取一个Camera 设备，对应于HAL中的camera3_device_t结构体 在Camera Provider层调用获取到的camera3_device_t的initialize方法进行初始化动作 代码大概流程走向 12345678910//APP 端 open CameraCameraManager::openCamera() //Camera Server CameraService::connectDevice() //通过HIDL接口 ICameraDevice::open() //camera provider camera_module_t::methods::open() //接下来就是进行一些初始化操作 camera3_device_t::initialize() APP Open Camera 流程App端主要做了以下几点工作 获取 CameraManager 服务 打开指定的 Camera 获取 Camera Server 调用 cameraService.connectDevice() 去连接打开设备，并且将上层传下来的回调传入Camera Server 返回Device给App端 123456789101112131415161718192021//apk端获取CameraManager 服务mCamManager = (CameraManager)getSystemService(Context.CAMERA_SERVICE); //打开指定camera--&gt; mCamManager.openCamera(mCameraId, mStateCallback, null); //frameworks/base/core/java/android/hardware/camera2/CameraManager.javapublic void openCamera(@NonNull String cameraId, @NonNull @CallbackExecutor Executor executor, @NonNull final CameraDevice.StateCallback callback) |--&gt; openCameraForUid(cameraId, callback, executor, USE_CALLING_UID) | |--&gt; openCameraDeviceUserAsync(cameraId, callback, executor, clientUid); | | |--&gt; CameraDevice device = null; //初始化CameraDevice | | | //实例化 new android.hardware.camera2.impl.CameraDeviceImpl | | |--&gt; android.hardware.camera2.impl.CameraDeviceImpl deviceImpl = new android.hardware.camera2.impl.CameraDeviceImpl(...) | | |--&gt; ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks(); //获取回调 | | |--&gt; ICameraService cameraService = CameraManagerGlobal.get().getCameraService(); //获取CameraService 服务 | | |--&gt; cameraUser = cameraService.connectDevice(callbacks, cameraId, mContext.getOpPackageName(), uid); //连接打开camera | | |--&gt; goto CONNECTDEVICE: //跳转到下面CONNECTDEVICE处进行分析 | | |--&gt; deviceImpl.setRemoteDevice(cameraUser); | | | |--&gt; mRemoteDevice = new ICameraDeviceUserWrapper(remoteDevice); | | | |--&gt; mDeviceExecutor.execute(mCallOnOpened); //这里是一个线程池 | | | | |--&gt; sessionCallback = mSessionStateCallback; //获取session cb | | | | |--&gt; sessionCallback.onOpened(CameraDeviceImpl.this); //通过session cb 返回device | | | | |--&gt; mDeviceCallback.onOpened(CameraDeviceImpl.this); //通过device cb 返回device,这里就是返回给apk端的CameraDevice了 Camera Server Open 流程对于打开相机设备动作,主要由connectDevice来实现，当CameraFramework通过调用ICameraService的connectDevice接口的时候,主要做了两件事情： 创建CameraDeviceClient。 对CameraDeviceClient进行初始化,并将其返回给Framework。 创建 CameraDevcieClientCameraDeviceClient 该类在打开设备的时候被实例化，一次打开设备的操作对应一个该类对象，它实现了ICameraDeviceUser接口，以AIDL方式暴露接口给Camera Framework进行调用，于此同时,该类在打开设备的过程中，获取了来自Camera Framework对于ICameraDeviceCallback接口的实现代理，通过该代理可以将结果上传至Camera Framewor中。我个人的理解其实这个类就是 framework 与 Camera 的通信入口。 代码流程如下： 首先实例化一个CameraDeviceClient 将来自Framework针对ICameraDeviceCallback的实现存入CameraDeviceClient中，一旦有结果产生便可以将结果通过这个回调回传给Framework 123456789//frameworks/av/services/camera/libcameraservice/CameraService.cppStatus CameraService::connectDevice(const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; cameraCb, const String16&amp; cameraId, const String16&amp; clientPackageName, int clientUid, sp&lt;hardware::camera2::ICameraDeviceUser&gt;* device) //最后一个参数是返回值 |--&gt; connectHelper&lt;hardware::camera2::ICameraDeviceCallbacks,CameraDeviceClient&gt;(...) //模板，CALLBACK 为hardware::camera2::ICameraDeviceCallbacks， CLIENT： CameraDeviceClient | |--&gt; validateConnectLocked(...) //关于一些权限的判断，如果没有权限或者非法访问这里会直接退出 | |--&gt; int deviceVersion = getDeviceVersion(cameraId, /*out*/&amp;facing) //获取device version, 为之后的实例化哪一个client 做准备 | |--&gt; makeClient(..., deviceVersion, effectiveApiLevel, ...) //这里主要是这两个参数决定了实例化哪一个client， | |--&gt; *client = new CameraDeviceClient(cameraService, tmp, packageName, cameraId,facing, clientPid, clientUid, servicePid) //这里是实例化了CameraDeviceClient | |--&gt; client = static_cast&lt;CLIENT*&gt;(tmp.get()); //取得makeClient中实例化好的client | |--&gt; client-&gt;initialize(mCameraProviderManager, mMonitorTags); //开始初始化 初始化 CameraDevcieClientCameraDeviceClient的初始化工作流程： 调用父类Camera2ClientBase的initialize方法进行初始化 实例化FrameProcessorBase对象并且将内部的Camera3Device对象传入其中,这样就建立了和Camera3Device的联系,之后将内部线程运行起来,等待来自Camera3Device的结果 将CameraDeviceClient注册到内部,这样就建立了与CameraDeviceClient的联系 123456789//file : frameworks/av/services/camera/libcameraservice/api2/CameraDeviceClient.cppstatus_t CameraDeviceClient::initialize(sp&lt;CameraProviderManager&gt; manager, const String8&amp; monitorTags) |--&gt; initializeImpl(manager, monitorTags) |--&gt; mFrameProcessor = new FrameProcessorBase(mDevice); //实例化FrameProcessorBase对象 | |--&gt; Camera2ClientBase::initialize(providerPtr, monitorTags) //file: frameworks/av/services/camera/libcameraservice/common/Camera2ClientBase.cpp | |--&gt; status_t Camera2ClientBase&lt;TClientBase&gt;::initialize(sp&lt;CameraProviderManager&gt; manager, const String8&amp; monitorTags) | | |--&gt; initializeImpl(manager, monitorTags) | | | |--&gt; mDevice-&gt;initialize(providerPtr, monitorTags) //这里的mDevice 是在 Camera2ClientBase初始化的时候传入的 mDevice(new Camera3Device(cameraId)) Camera3Device 结构介绍 主要实现了对Camera Provider 的ICameraDeviceCallbacks会调接口的实现，通过该接口接收来自Provider的结果上传进而传给CameraDeviceClient Camera3Device会将事件通过notify方法给到CameraDeviceClient Camera3Device中RequestThread主要用于处理Request的接收与下发工作 Camera3Device 初始化 通过调用CameraProviderManager的openSession方法打开并获取一个Provider中的ICameraDeviceSession代理 实例化一个HalInterface对象,将之前获取的ICameraDeviceSession代理存入其中,最后将RequestThread线程运行起来,等待request的下发 123456789//file: device3/Camera3Device.cpp status_t Camera3Device::initialize(sp&lt;CameraProviderManager&gt; manager, const String8&amp; monitorTags) |--&gt; status_t res = manager-&gt;openSession(mId.string(), this, /*out*/ &amp;session) //CameraProviderManager openSession //file: common/CameraProviderManager.cpp | |--&gt; status_t CameraProviderManager::openSession(const std::string &amp;id, const sp&lt;device::V3_2::ICameraDeviceCallback&gt;&amp; callback, sp&lt;device::V3_2::ICameraDeviceSession&gt; *session) | | |--&gt; auto interface = deviceInfo3-&gt;startDeviceInterface&lt;CameraProviderManager::ProviderInfo::DeviceInfo3::InterfaceT&gt;() | | | |--&gt; const sp&lt;provider::V2_4::ICameraProvider&gt; interface = startProviderInterface() //获取provider | | | |--&gt; interface-&gt;getCameraDeviceInterface_V3_x(name, [&amp;status, &amp;cameraInterface](hidl_cb) //这里的hidl_cb 指的是回调接口，provider 会将device 指针返回回来，当然这个指针是跨进程能够调用的，具体怎么实现的暂时不清楚，暂且不管 | | |--&gt; interface-&gt;open(callback, [&amp;status, &amp;session](Status s, const sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession) //这里就调用的provider部分的Device的open接口 FrameProcessBase 结构介绍 meta data以及image data 会给到 FrameProcessBase FrameProcessBase主要用于metadata以及image data的中转处理 Provider Open 流程123456789//file: device/3.2/default/CameraDevice.cppReturn&lt;void&gt; CameraDevice::open(const sp&lt;ICameraDeviceCallback&gt;&amp; callback, ICameraDevice::open_cb _hidl_cb) //这里的mModule 是CameraModule实例，在provider调用etCameraDeviceInterface_V3_x 方法时通过实例化device deviceImpl = new //android::hardware::camera::device::V3_4::implementation::CameraDevice(mModule, cameraId, mCameraDeviceNames) 传入， //而mModule 是在provider初始化的时候创建，里面获取了camera hw module实例,关于proviser的初始化参见provider_initialize |--&gt; mModule-&gt;open(mCameraId.c_str(), reinterpret_cast&lt;hw_device_t**&gt;(&amp;device)) //file: common/1.0/default/CameraModule.cpp |--&gt; int CameraModule::open(const char* id, struct hw_device_t** device) | |--&gt; filterOpenErrorCode(mModule-&gt;common.methods-&gt;open(&amp;mModule-&gt;common, id, device)) Camx Open 流程","tags":[{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"}]},{"title":"Centos 开发环境的搭建","date":"2019-12-31T16:00:02.000Z","path":"undefined/计算机基础知识/Centos 开发环境的搭建/","text":"同一网段外部浏览器不能访问Tomcat 问题产生背景和原因 背景：服务器已经安装好tomcat, 服务器主机通过 ip+8080 的方式可以进行访问, 但是其他在同一网段下的客户端机器通过同样方式不能访问. 原因：服务器未将 8080 端口进行开放 解决方法 1)查看防火墙状态 1firewall-cmd --state 2)添加需要开放的端口 1firewall-cmd --permanent --zone=public --add-port=8080/tcp 3)加载配置使其生效 1firewall-cmd --reload 4)查看配置是否生效 1firewall-cmd --permanent --zone=public --list-ports 5)重新访问 Tomcat (IP+8080) 防火墙的相关操作 开启防火墙的命令 1systemctl start firewalld.service 关闭防火墙的命令 1systemctl stop firewalld.service 开机自动启动 1systemctl enable firewalld.service 关闭开机自动启动 1systemctl disable firewalld.service 查看防火墙状态 1systemctl status firewalld","tags":[{"name":"Centos","slug":"Centos","permalink":"https://zh-wiki.github.io/tags/Centos/"}],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Repo 常用命令","date":"2019-12-31T16:00:02.000Z","path":"undefined/技术研发/Linux 命令/Repo 常用指令/","text":"repo 拉下来的代码如何新建分支1repo start xxx(分支名) --all repo sync 的时候如果有本地未提交的修改1repo forall -cv &quot;git reset HEAD --hard; git clean -df &quot; -j32","tags":[],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Linux 命令","slug":"技术研发/Linux-命令","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"}]},{"title":"高通 Camx camera provider","date":"2019-12-31T16:00:02.000Z","path":"undefined/技术研发/Camera Driver/高通 Camx/高通 Camx camera provider/","text":"概览 通过图片可以看出Camera Provider 分为两部分 通过 HIDL 与Camera Service 跨进程通信 通过 dlopen 方式加载一系列动态库 （Camera HAL3结构的so），在高通Camera 是指 camx-chi 架构 camera provider 和 camera hal3 的联系HAL硬件抽象层(Hardware Abstraction Layer),是谷歌开发的用于屏蔽底层硬件抽象出来的一个软件层，该层定义了自己的一套通用标准接口,平台厂商务必按照以下规则定义自己的Module 每一个硬件都通过hw_module_t来描述,具有固定的名字HMI 每一个硬件都必须实现hw_module_t里面的open方法,用于打开硬件设备,并返回对应的操作接口集合 硬件的操作接口集合使用hw_device_t 来描述,并可以通过自定义一个更大的包含hw_device_t的结构体来拓展硬件操作集合 HAL3 结构体介绍 hw_module_t 1234567891011121314151617typedef struct hw_module_t &#123; uint32_t tag; uint16_t module_api_version;#define version_major module_api_version uint16_t hal_api_version;#define version_minor hal_api_version const char *id; const char *name; const char *author; struct hw_module_methods_t* methods; void* dso;#ifdef __LP64__ uint64_t reserved[32-7];#else uint32_t reserved[32-7];#endif&#125; hw_module_t; hw_module_methods_t 12345typedef struct hw_module_methods_t &#123; /** Open a specific device */ int (*open)(const struct hw_module_t* module, const char* id, struct hw_device_t** device);&#125; hw_module_methods_t; hw_device_t 12345678910111213typedef struct hw_device_t &#123; uint32_t tag; uint32_t version; struct hw_module_t* module;#ifdef __LP64__ uint64_t reserved[12];#else uint32_t reserved[12];#endif int (*close)(struct hw_device_t* device); &#125; hw_device_t; 从上面的定义可以看出 hw_module_t 代表了模块，通过其open方法用来打开一个设备 设备是用hw_device_t来表示，其中除了用来关闭设备的close方法外,并无其它方法 由此可见谷歌定义的HAL接口,并不能满足绝大部分HAL模块的需要,所以谷歌想出了一个比较好的解决方式,那便是将这两个基本结构嵌入到更大的结构体内部,同时在更大的结构内部定义了各自模块特有的方法,用于实现模块的功能,这样,一来对上保持了HAL的统一规范,二来也扩展了模块的功能 高通 camx HAL3 结构体 camera_module_t 123456789101112131415typedef struct camera_module &#123; hw_module_t common; int (*get_number_of_cameras)(void); int (*get_camera_info)(int camera_id, struct camera_info *info); int (*set_callbacks)(const camera_module_callbacks_t *callbacks); void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops); int (*open_legacy)(const struct hw_module_t* module, const char* id, uint32_t halVersion, struct hw_device_t** device); int (*set_torch_mode)(const char* camera_id, bool enabled); int (*init)(); int (*get_physical_camera_info)(int physical_camera_id, camera_metadata_t **static_metadata); int (*is_stream_combination_supported)(int camera_id, const camera_stream_combination_t *streams); void (*notify_device_state_change)(uint64_t deviceState); int (*get_camera_device_version)(int camera_id, uint32_t *version); void* reserved[1];&#125; camera_module_t; camera3_device_t 12345typedef struct camera3_device &#123; hw_device_t common; camera3_device_ops_t *ops; void *priv;&#125; camera3_device_t; camera_module_t包含了hw_module_t，主要用于表示Camera模块，其中定义了诸如get_number_of_cameras以及set_callbacks等扩展方法 camera3_device_t包含了hw_device_t,主要用来表示Camera设备,其中定义了camera3_device_ops操作方法集合,用来实现正常获取图像数据以及控制Camera的功能 Camera HAL3 的实现1234567891011121314151617181920CAMX_VISIBILITY_PUBLIC camera_module_t HAL_MODULE_INFO_SYM =&#123; .common = &#123; .tag = HARDWARE_MODULE_TAG, .module_api_version = CAMERA_MODULE_API_VERSION_CURRENT, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = CAMERA_HARDWARE_MODULE_ID, .name = &quot;QTI Camera HAL&quot;, .author = &quot;Qualcomm Technologies, Inc.&quot;, .methods = &amp;CamX::g_hwModuleMethods &#125;, .get_number_of_cameras = CamX::get_number_of_cameras, .get_camera_info = CamX::get_camera_info, .set_callbacks = CamX::set_callbacks, .get_vendor_tag_ops = CamX::get_vendor_tag_ops, .open_legacy = NULL, .set_torch_mode = CamX::set_torch_mode, .init = CamX::init&#125;; 没错高通 camx hal3 的入口就是这个，在遵循HAL3规范的前提下，实例化各个接口。Provider 将会调用 hw_get_module() 来获取该入口。 各个接口映射到 camxhal3.cpp 1static Dispatch g_dispatchHAL3(&amp;g_jumpTableHAL3); 123456789101112131415161718192021222324252627JumpTableHAL3 g_jumpTableHAL3 =&#123; open, get_number_of_cameras, get_camera_info, set_callbacks, get_vendor_tag_ops, open_legacy, set_torch_mode, init, get_tag_count, get_all_tags, get_section_name, get_tag_name, get_tag_type, close, initialize, configure_streams, construct_default_request_settings, process_capture_request, dump, flush, camera_device_status_change, torch_mode_status_change, process_capture_result, notify&#125;; Provider init 代码流程 在系统初始化的时候，系统会去运行”&#97;&#x6e;&#x64;&#x72;&#111;&#x69;&#100;&#x2e;&#104;&#97;&#114;&#x64;&#119;&#x61;&#114;&#101;&#x2e;&#x63;&#x61;&#x6d;&#101;&#x72;&#97;&#46;&#x70;&#x72;&#111;&#x76;&#105;&#x64;&#101;&#x72;&#x40;&#50;&#x2e;&#x34;&#45;&#115;&#x65;&#x72;&#118;&#x69;&#x63;&#101;&#95;&#x36;&#x34;“程序启动Provider进程，并加入HW Service Manager中接受统一管理。在改过程中实例化一个 LegacyCameraProviderImpl_2_4 对象，通过 hw_get_module 标准方法 获取HAL 模块。这边指的是 camera.qcom.so 。 Camera Provider Init 函数总括123456789101112131415161718192021// hardware/interfaces/camera/provider/2.4/default/LegacyCameraProviderImpl_2_4.cppbool LegacyCameraProviderImpl_2_4::initialize() &#123; camera_module_t *rawModule; //获取 camera.qcom.so 可以理解为和 camxhal3entry.cpp 建立联系 int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;rawModule); //将 camera.qcom.so 获取的句柄保存在 mModule 对象中 ，该函数定义在 CameraModule.cpp mModule = new CameraModule(rawModule); //我们可以跟进去看看 init() 非常明显 实际就是进行 camx 的初始化，camxhal3entry.cpp &#123; CAMX:: init()&#125; //int CameraModule::init() 这个函数将会调用 getNumberOfCameras() //就此 camx-chi 的一系列初始化操作 拉开序幕 err = mModule-&gt;init(); // 设置回调函数，用于接受camx-chi的数据和事件 err = mModule-&gt;setCallbacks(this); mNumberOfLegacyCameras = mModule-&gt;getNumberOfCameras(); return false; // mInitFailed&#125; init 函数结束之后，Camera Provider进程便一直便存在于系统中,监听着来自Camera Service的调用。 Camera Provider Init 分解通过上面的总括可以理解为 Provider 最终目的获取 Camx-Chi 的 setting 以及 HW 资源。然后保存起来返回给上层，供后面使用。 二话不说先上一张大图 get_number_of_cameras 函数介绍这个函数是一切美好的开始，她的最先调用就是上面介绍的provide init 函数的 CameraModule::init() 123456789101112131415//hardware/interfaces/camera/common/1.0/default/CameraModule.cppint CameraModule::init() &#123; ATRACE_CALL(); int res = OK; if (getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_4 &amp;&amp; mModule-&gt;init != NULL) &#123; ATRACE_BEGIN(&quot;camera_module-&gt;init&quot;); res = mModule-&gt;init(); ATRACE_END(); &#125; //将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3.cpp中 mNumberOfCameras = getNumberOfCameras(); mCameraInfoMap.setCapacity(mNumberOfCameras); return res;&#125; CameraModule::init() ，这个函数调用 getNumberOfCameras() 。最终调用到 get_number_of_cameras() 这个函数已经是干到camx了。 1234567891011//vendor/proprietary/camx/src/coer/hal/camxhal3.cppstatic int get_number_of_cameras(void)&#123; ...... INT numCameras; //将会走到 vendor/proprietary/camx/src/coer/hal/camxhal3module.cpp中 //会调用到 HAL3Module的构造函数 numCameras = static_cast&lt;int&gt;(HAL3Module::GetInstance()-&gt;GetNumCameras()); ...... return numCameras;&#125; 这个函数主要有两个作用： 是通过 HAL3Module 类的构造函数会获取 CAMX-CHI 的信息 加载 com.qti.chi.override.so 模块，映射 CAMX-CHI 之间的接口 12345678910111213141516//vendor/proprietary/camx/src/coer/hal/camxhal3module.cppHAL3Module::HAL3Module()&#123; CamxResult result = CamxResultSuccess; CSLCameraPlatform CSLPlatform = &#123;&#125;; CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;***************************************************&quot;); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;SHA1: %s&quot;, CAMX_SHA1); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;COMMITID: %s&quot;, CAMX_COMMITID); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;BUILD TS: %s&quot;, CAMX_BUILD_TS); CAMX_LOG_CONFIG(CamxLogGroupHAL, &quot;***************************************************&quot;); ...... //到了这个位置已经是很亲切了，干到camx了 m_pStaticSettings = HwEnvironment::GetInstance()-&gt;GetStaticSettings(); ......&#125; HwEnvironment::Initialize() 函数介绍通过 HAL3Module 构造函数会调用 HwEnvironment 类的构造，主体功能在 HwEnvironment::Initialize() 中实现 HwEnvironment::Initialize() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//vendor/proprietary/camx/src/coer/camxhwenvironment.cppCamxResult HwEnvironment::Initialize()&#123; CamxResult result = CamxResultSuccess; CSLInitializeParams params = &#123; 0 &#125;; SettingsManager* pStaticSettingsManager = SettingsManager::Create(NULL); ExternalComponentInfo* pExternalComponent = GetExternalComponent(); if (NULL != pStaticSettingsManager) &#123; const StaticSettings* pStaticSettings = pStaticSettingsManager-&gt;GetStaticSettings(); if (NULL != pStaticSettings) &#123; params.mode = pStaticSettings-&gt;CSLMode; params.emulatedSensorParams.enableSensorSimulation = pStaticSettings-&gt;enableSensorEmulation; params.emulatedSensorParams.dumpSensorEmulationOutput = pStaticSettings-&gt;dumpSensorEmulationOutput; OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulatorPath, pStaticSettings-&gt;sensorEmulatorPath, sizeof(pStaticSettings-&gt;sensorEmulatorPath)); OsUtils::StrLCpy(params.emulatedSensorParams.sensorEmulator, pStaticSettings-&gt;sensorEmulator, sizeof(pStaticSettings-&gt;sensorEmulator)); result = CSLInitialize(&amp;params); if (CamxResultSuccess == result) &#123; // Query the camera platform result = QueryHwContextStaticEntryMethods(); &#125; if (CamxResultSuccess == result) &#123; m_pHwFactory = m_staticEntryMethods.CreateHwFactory(); if (NULL == m_pHwFactory) &#123; CAMX_ASSERT_ALWAYS_MESSAGE(&quot;Failed to create the HW factory&quot;); result = CamxResultEFailed; &#125; &#125; if (CamxResultSuccess == result) &#123; m_pSettingsManager = m_pHwFactory-&gt;CreateSettingsManager(); if (NULL == m_pSettingsManager) &#123; CAMX_ASSERT_ALWAYS_MESSAGE(&quot;Failed to create the HW settings manager&quot;); result = CamxResultEFailed; &#125; &#125; if (CamxResultSuccess == result) &#123; m_staticEntryMethods.GetHWBugWorkarounds(&amp;m_workarounds); &#125; &#125; pStaticSettingsManager-&gt;Destroy(); pStaticSettingsManager = NULL; &#125; CAMX_ASSERT(NULL != pExternalComponent); if ((CamxResultSuccess == result) &amp;&amp; (NULL != pExternalComponent)) &#123; result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent); &#125; if (CamxResultSuccess == result) &#123; // Load the OEM sensor capacity customization functions CAMXCustomizeCAMXInterface camxInterface; camxInterface.pGetHWEnvironment = HwEnvironment::GetInstance; CAMXCustomizeEntry(&amp;m_pOEMInterface, &amp;camxInterface); &#125; if (CamxResultSuccess != result) &#123; CAMX_LOG_ERROR(CamxLogGroupCore, &quot;FATAL ERROR: Raise SigAbort. HwEnvironment initialization failed&quot;); m_numberSensors = 0; OsUtils::RaiseSignalAbort(); &#125; else &#123; m_initCapsStatus = InitCapsInitialize; &#125; return result;&#125; 通过上面的代码可以看出 HwEnvironment::Initialize() 做的事情还是挺多的。下面我们开始分析 获取camx的相关配置 SettingsManager* pStaticSettingsManager = SettingsManager::Create(NULL); 经过一系列调用最终会调到以下代码，加载配置参数 123456789101112131415161718192021//vendor/proprietary/camx/src/coer/camxsettingsmanager.cppCamxResult SettingsManager::Initialize( StaticSettings* pStaticSettings)&#123; ...... // Populate the default settings InitializeDefaultSettings(); InitializeDefaultDebugSettings(); // Load the override settings from our override settings stores result = LoadOverrideSettings(m_pOverrideSettingsStore); result = LoadOverrideProperties(m_pOverrideSettingsStore, TRUE); result = ValidateSettings(); DumpSettings(); m_pOverrideSettingsStore-&gt;DumpOverriddenSettings(); ...... UpdateLogSettings(); return result;&#125; 利用加载好的配置参数去初始化相关模块 result = CSLInitialize(&amp;params); 经过一个跳转表格进入以下代码 CamxResult CSLInitializeHW() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//vendor/proprietary/camx/src/csl/hw/camxcslhw.cppCamxResult CSLInitializeHW()&#123; CamxResult result = CamxResultEFailed; CHAR syncDeviceName[CSLHwMaxDevName] = &#123;0&#125;; if (FALSE == CSLHwIsHwInstanceValid()) &#123; if (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideodevice, CAM_VNODE_DEVICE_TYPE)) &#123; if (TRUE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdevice, CAM_CPAS_DEVICE_TYPE)) &#123; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Platform family=%d, version=%d.%d.%d, cpas version=%d.%d.%d&quot;, g_CSLHwInstance.pCameraPlatform.family, g_CSLHwInstance.pCameraPlatform.platformVersion.majorVersion, g_CSLHwInstance.pCameraPlatform.platformVersion.minorVersion, g_CSLHwInstance.pCameraPlatform.platformVersion.revVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.majorVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.minorVersion, g_CSLHwInstance.pCameraPlatform.CPASVersion.revVersion); if (FALSE == CSLHwEnumerateAndAddCSLHwDevice(CSLInternalHwVideoSubdeviceAll, 0)) &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;No KMD devices found&quot;); &#125; else &#123; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Total KMD subdevices found =%d&quot;, g_CSLHwInstance.kmdDeviceCount); &#125; // Init the memory manager data structures here CamX::Utils::Memset(g_CSLHwInstance.memManager.bufferInfo, 0, sizeof(g_CSLHwInstance.memManager.bufferInfo)); // Init the sync manager here g_CSLHwInstance.lock-&gt;Lock(); g_CSLHwInstance.pSyncFW = CamX::SyncManager::GetInstance(); if (NULL != g_CSLHwInstance.pSyncFW) &#123; CSLHwGetSyncHwDevice(syncDeviceName, CSLHwMaxDevName); CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Sync device found = %s&quot;, syncDeviceName); result = g_CSLHwInstance.pSyncFW-&gt;Initialize(syncDeviceName); if (CamxResultSuccess != result) &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;CSL failed to initialize SyncFW&quot;); result = g_CSLHwInstance.pSyncFW-&gt;Destroy(); g_CSLHwInstance.pSyncFW = NULL; &#125; &#125; g_CSLHwInstance.lock-&gt;Unlock(); CSLHwInstanceSetState(CSLHwValidState); result = CamxResultSuccess; CAMX_LOG_VERBOSE(CamxLogGroupCSL, &quot;Successfully acquired requestManager&quot;); &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;Failed to acquire CPAS&quot;); &#125; &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;Failed to acquire requestManager invalid&quot;); &#125; &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupCSL, &quot;CSL in Invalid State&quot;); &#125; return result;&#125; 这一部分我个人理解为，遍历所有kernel端的设备。获取相关接口以及需要的事件。与HAL层建立联系。具体分析以后可以单独写一篇文章分析 根据平台获取对应的入口方法 这个暂时不知道是个什么鬼，先这样理解 result = QueryHwContextStaticEntryMethods(); 经过一系列的调用最终是跑到了这里 12345678910111213141516//vendor/proprietary/camx/src/csl/hwl/titan17x/camxtitan17xhwl.cppCamxResult Titan17xGetStaticEntryMethods( HwContextStaticEntry* pStaticEntry)&#123; CamxResult result = CamxResultSuccess; pStaticEntry-&gt;Create = &amp;Titan17xContext::Create; pStaticEntry-&gt;GetStaticMetadataKeysInfo = &amp;Titan17xContext::GetStaticMetadataKeysInfo; pStaticEntry-&gt;GetStaticCaps = &amp;Titan17xContext::GetStaticCaps; pStaticEntry-&gt;CreateHwFactory = &amp;Titan17xFactory::Create; pStaticEntry-&gt;QueryVendorTagsInfo = &amp;Titan17xContext::QueryVendorTagsInfo; pStaticEntry-&gt;GetHWBugWorkarounds = &amp;Titan17xContext::GetHWBugWorkarounds; pStaticEntry-&gt;QueryExternalComponentVendorTagsInfo = &amp;Titan17xContext::QueryExternalComponentVendorTagsInfo; return result;&#125; 获取CHI各个节点的接口 result = ProbeChiComponents(pExternalComponent, &amp;m_numExternalComponent); 遍历所有chi相关的.so库，将各个接口保存起来。这一块的代码撸的比较少，先记录这么多 到此处 HwEnvironment::Initialize() 这个函数就介绍的差不多了。日后慢慢完善 HwEnvironment::InitCaps() 函数介绍 HwEnvironment::InitCaps() 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//vendor/proprietary/camx/src/coer/camxhwenvironment.cppVOID HwEnvironment::InitCaps()&#123; CamxResult result = CamxResultSuccess; m_pHWEnvLock-&gt;Lock(); if (InitCapsRunning == m_initCapsStatus || InitCapsDone == m_initCapsStatus) &#123; m_pHWEnvLock-&gt;Unlock(); return; &#125; m_initCapsStatus = InitCapsRunning; if (CamxResultSuccess == result) &#123; EnumerateDevices(); ProbeImageSensorModules(); EnumerateSensorDevices(); InitializeSensorSubModules(); InitializeSensorStaticCaps(); result = m_staticEntryMethods.GetStaticCaps(&amp;m_platformCaps[0]); // copy the static capacity to remaining sensor&#x27;s for (UINT index = 1; index &lt; m_numberSensors; index++) &#123; Utils::Memcpy(&amp;m_platformCaps[index], &amp;m_platformCaps[0], sizeof(m_platformCaps[0])); &#125; if (NULL != m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps) &#123; m_pOEMInterface-&gt;pInitializeExtendedPlatformStaticCaps(&amp;m_platformCaps[0], m_numberSensors); &#125; &#125; CAMX_ASSERT(CamxResultSuccess == result); if (CamxResultSuccess == result) &#123; InitializeHwEnvironmentStaticCaps(); &#125; m_initCapsStatus = InitCapsDone; m_pHWEnvLock-&gt;Unlock();&#125; 这一波操作应该就是枚举各个Camera模组，检测硬件是否可以通信成功。 Probe Sensor 经过上述函数中 ProbeImageSensorModules() 会走到 ImageSensorModuleData::Probe() 1234567891011121314151617//vendor/proprietary/camx/src/core/camximagesensormoduledata.cppCamxResult ImageSensorModuleData::Probe( BOOL* pDetected, INT32* pDeviceIndex)&#123; ...... //获取上下电时序 UINT powerUpCmdSize = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(TRUE); UINT powerDownCmdSize = GetSensorDataObject()-&gt;GetPowerSequenceCmdSize(FALSE); //创建命令包管理 result = CmdBufferManager::Create(&quot;ImageSensorPacketManager&quot;, &amp;packetResourceParams, &amp;pPacketManager); //向CSL下发probe命令 result = CSLImageSensorProbe(pProbePacket-&gt;GetMemHandle(), pProbePacket-&gt;GetOffset(), &amp;probeResult); ......&#125; 该函数的主要作用就是创建probe sensor 的命令包，然后下发到CSL 将命令包提交到 CSL 通过ioctl下发到 Kernel 123456789101112131415//vendor/qcom/proprietary/camx/src/csl/hw/camxcslhwinternalsensor.cppCamxResult CSLHwInternalProbeSensorHW( CSLMemHandle hPacket, SIZE_T offset, INT32* pDeviceIndex)&#123; ...... ioctlCmd.op_code = CAM_SENSOR_PROBE_CMD; ioctlCmd.size = sizeof(ioctlCmd.handle); ioctlCmd.handle_type = CAM_HANDLE_MEM_HANDLE; ioctlCmd.reserved = 0; ioctlCmd.handle = hPacket; result = pLoophw-&gt;deviceOp.Ioctl(pLoophw, VIDIOC_CAM_CONTROL, &amp;ioctlCmd); ......&#125;","tags":[{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"}]},{"title":"Hexo 博客搭建","date":"2019-12-31T16:00:01.000Z","path":"undefined/计算机基础知识/Hexo 博客搭建/","text":"安装 Hexo 1sudo npm install --unsafe-perm --verbose -g hexo 同步本地图片与网络图片 安装插件 1npm install https://github.com/CodeFalling/hexo-asset-image --save 配置Typora 编译 有以下log说明配置成功 Wikitten 主题关闭自动标号 修改路径文件：/themes/Wikitten/layout/common/article.ejs","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zh-wiki.github.io/tags/Hexo/"}],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Git 常用命令","date":"2019-12-31T16:00:01.000Z","path":"undefined/技术研发/Linux 命令/Git 常用命令/","text":"基本配置 所有的命令输出在同一页显示 1git config --global core.pager &#x27;&#x27; 撤销指令 撤销工作区的修改 git checkout 文件名 git checkout 目录 -f 从暂存区撤销到工作区（可以理解为git add的反向动作） git reset HEAD 从版本库撤销到暂存区 git reset –soft HEAD^ 从版本库撤销到工作区 git reset –mixed HEAD^ 撤销到上一次提交（本地修改丢失） git reset –hard HEAD^ 保存恢复指令 保存本地未追踪的修改 git stash save 路径 将保存的内容导出 git stash pop stash@{index} 获取保存列表 git stash list 解决冲突这里我分为两种情况： 代码提到服务器上。 a. 首先把自己的提交reset掉。 b.更新代码 c.将自己的代码从服务器上拉下来。 d.冲突用code工具解决掉。然后add 修改文件，重新commit 代码在本地提交 a.将本地提交撤回到工作区。 b.保存本地修改 c.更新代码 d.将保存的代码还原。 e.冲突用code工具解决掉。然后add 修改文件，重新commit","tags":[{"name":"Linux 命令","slug":"Linux-命令","permalink":"https://zh-wiki.github.io/tags/Linux-%E5%91%BD%E4%BB%A4/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Linux 命令","slug":"技术研发/Linux-命令","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"}]},{"title":"三星o1o2o3项目随笔","date":"2019-12-31T16:00:01.000Z","path":"undefined/技术研发/项目随笔/三星o1o2o3项目随笔/","text":"项目相关 平台 高通 sdm439 mm-camera 架构 PLM 账号密码 登录网址（IE浏览器）：http://myproject.samsungmobile.com 账号：junwei2 密码：ZJWzhq1314 XTS 问题相关 CTS 测试 工厂版本测试，正常版本测试只需要测试2颗摄像头，主摄和前摄，测试结果报cameraid 2, 3,4 的一律不看。 如果出现测试过程中，由于某一项卡住，或者timeout 导致测试失败。有可能是没有暴露两颗摄像头给CTS. 可以参考一下修改，编译生成的库libcamera2ndk.so .push 路径：system/lib 暴露两颗模组给CTS 1234567891011121314151617181920212223242526272829303132333435363738394041424344//frameworks/av/camera/ndk/impl/ACameraManager.cppcamera_status_tACameraManager::getCameraIdList(ACameraIdList** cameraIdList) &#123; Mutex::Autolock _l(mLock); std::vector&lt;String8&gt; idList; CameraManagerGlobal::getInstance().getCameraIdList(&amp;idList); int numCameras = idList.size(); ACameraIdList *out = new ACameraIdList; if (!out) &#123; ALOGE(&quot;Allocate memory for ACameraIdList failed!&quot;); return ACAMERA_ERROR_NOT_ENOUGH_MEMORY; &#125; //这里强制暴露2颗模组给 CTS //Expose two cameras fot CTS tests begin by zangyufei@huaqin.com if(numCameras &gt; 2) &#123; numCameras = 2; ALOGE(&quot;Expose two cameras numCameras %d&quot;,numCameras); &#125; //Expose two cameras fot CTS tests end by zangyufei@huaqin.com out-&gt;numCameras = numCameras; out-&gt;cameraIds = new const char*[numCameras]; if (!out-&gt;cameraIds) &#123; ALOGE(&quot;Allocate memory for ACameraIdList failed!&quot;); deleteCameraIdList(out); return ACAMERA_ERROR_NOT_ENOUGH_MEMORY; &#125; for (int i = 0; i &lt; numCameras; i++) &#123; const char* src = idList[i].string(); size_t dstSize = strlen(src) + 1; char* dst = new char[dstSize]; if (!dst) &#123; ALOGE(&quot;Allocate memory for ACameraIdList failed!&quot;); deleteCameraIdList(out); return ACAMERA_ERROR_NOT_ENOUGH_MEMORY; &#125; strlcpy(dst, src, dstSize); out-&gt;cameraIds[i] = dst; &#125; *cameraIdList = out; return ACAMERA_OK;&#125; GSI 问题以及解决方案 camcorder profile 报错 通错测试报错可以发现 camcorder profile 报错，出现这个问题就要考虑编码器配置的问题. 一般编码器的配置文件在以下路径 这么多的profile调用哪一个，opengrok来一把 直接搜索测试项的关键字 （testRecordingFramerateLowToHigh） 123public void testRecordingFramerateLowToHigh() throws Exception &#123; CamcorderProfile profile = CamcorderProfile.get(cameraId, profileId); //获取media profile&#125; 通过 CamcorderProfile 这个类我们可以知道native层有相关方法的实现 应该是在init的时候把media_profile获取到 ，来看看如何获取media_profile的 请看这个函数 MediaProfiles::getInstance() 通过代码看，根据属性来决定的，如果没有找到xml文件会有log。好的check一下 12//通过这个log也能看到 编码器初始化失败了 08-27 12:10:37.454 924 19018 E OMX-VENC: ERROR: venc_start(): Driver Profile/Level is NOT SET Oh 真的有，说明代码走的是上面的if ，接下来分析 getXmlPaths 为啥没有get到 通过分析代码应该是需要get media_profiles_V1_0.xml 这么一个xml, 但是我们手机中并没有 最后通过搜索之后发现并有将文件拷贝到手机 device/qcom/msm8953_32/msm8953_32.mk 解决方法只需要在下面add 一行即可 Golden Bin 相关 golden.bin 导入 在导入golden.bin的时候发现路径找不到 解决方法(通过opengrok搜索关键字 dualcali_golden_xx.bin(参考提交)) 配置golden.bin的相关xml 通过以下配置发现golden.bin路径并非我们存放的位置 1234path: factory/config/HS50/sensor_config.xml&lt;Item rear_camera=&quot;hi1336_hs50_hlt : HQ20207953000&quot; sub_camera= &quot;gc02m1_hs50_ly : HQ20207879000&quot; filepath=&quot;/vendor/lib/dualcali_golden_22.bin&quot;&gt;&lt;/Item&gt;&lt;Item rear_camera=&quot;hi1336_hs50_hlt : HQ20207953000&quot; sub_camera= &quot;gc2375h_hs50_sjc : HQ20200002SJC&quot; filepath=&quot;/vendor/lib/dualcali_golden_23.bin&quot;&gt;&lt;/Item&gt;&lt;Item rear_camera=&quot;hi1336_hs50_hlt : HQ20207953000&quot; sub_camera= &quot;gc2375h_hs50_cxt : HQ20207875000&quot; filepath=&quot;/vendor/lib/dualcali_golden_24.bin&quot;&gt;&lt;/Item&gt; open grok 搜关键字 LIB_GOLDEN_BASE 或者 libGoldenArc (上面的路径) 会发现有个copy的过程","tags":[{"name":"项目随笔","slug":"项目随笔","permalink":"https://zh-wiki.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"项目随笔","slug":"技术研发/项目随笔","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"}]},{"title":"高通 Camx camera server","date":"2019-12-31T16:00:01.000Z","path":"undefined/技术研发/Camera Driver/高通 Camx/高通 Camx camera server/","text":"Camera ServerCamera Server 是一个独立的进程，对上通过AIDL来完成 Camera Framework 的一些请求；对下通过HIDL 将上层发下来的请求提交给 Camera Provider。 Camera Server 对 Camera Framework 而言属于 服务端 Camera Server 对 Camera Provider 而言属于 客户端","tags":[{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"}]},{"title":"从零开始写V4L2应用程序","date":"2019-12-31T16:00:01.000Z","path":"undefined/技术研发/Linux Driver/V4L2/V4L2 从零开始写应用程序/","text":"打开设备 配置 (获取支持的格式) 申请内核缓冲区队列 把内核的缓冲区队列映射到用户空间 开始采集 采集数据 停止采集 释放映射 关闭设备 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;linux/videodev2.h&gt;#include &lt;string.h&gt;#include &lt;sys/mman.h&gt;#include &lt;jpeglib.h&gt;#include &lt;linux/fb.h&gt;int read_JPEG_file (const char *jpegData, char *rgbdata, int size)&#123; struct jpeg_error_mgr jerr; struct jpeg_decompress_struct cinfo; cinfo.err = jpeg_std_error(&amp;jerr); //1创建解码对象并且初始化 jpeg_create_decompress(&amp;cinfo); //2.装备解码的数据 //jpeg_stdio_src(&amp;cinfo, infile); jpeg_mem_src(&amp;cinfo,jpegData, size); //3.获取jpeg图片文件的参数 (void) jpeg_read_header(&amp;cinfo, TRUE); /* Step 4: set parameters for decompression */ //5.开始解码 (void) jpeg_start_decompress(&amp;cinfo); //6.申请存储一行数据的内存空间 int row_stride = cinfo.output_width * cinfo.output_components; unsigned char *buffer = malloc(row_stride); int i=0; while (cinfo.output_scanline &lt; cinfo.output_height) &#123; //printf(&quot;****%d\\n&quot;,i); (void) jpeg_read_scanlines(&amp;cinfo, &amp;buffer, 1); memcpy(rgbdata+i*640*3, buffer, row_stride ); i++; &#125; //7.解码完成 (void) jpeg_finish_decompress(&amp;cinfo); //8.释放解码对象 jpeg_destroy_decompress(&amp;cinfo); return 1;&#125;int lcdfd =0;unsigned int *lcdptr = NULL;int lcd_w = 800, lcd_h= 480;void lcd_show_rgb(unsigned char* rgbdata, int w, int h)&#123; unsigned int *ptr = lcdptr; for(int i=0; i&lt;h; i++) &#123; for(int j=0; j&lt;w; j++) &#123; memcpy(ptr+j, rgbdata+j*3, 3); &#125; ptr+=lcd_w; rgbdata+=w*3; &#125;&#125;int main(void)&#123; lcdfd = open(&quot;/dev/fb0&quot;, O_RDWR); struct fb_var_screeninfo info; int lret = ioctl(lcdfd, FBIOGET_VSCREENINFO, &amp;info); lcd_w = info.xres_virtual; lcd_h = info.yres_virtual; lcdptr = (unsigned int *)mmap(NULL, lcd_w*lcd_h*4,PROT_READ|PROT_WRITE, MAP_SHARED, lcdfd ,0); //1.打开设备 int fd = open(&quot;/dev/video2&quot;, O_RDWR); if(fd &lt; 0) &#123; perror(&quot;打开设备失败&quot;); return -1; &#125; //3.设置采集格式 struct v4l2_format vfmt; vfmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;//摄像头采集 vfmt.fmt.pix.width = 640;//设置宽（不能任意） vfmt.fmt.pix.height = 480;//设置高 //vfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;//设置视频采集格式 vfmt.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;//设置视频采集格式 int ret = ioctl(fd, VIDIOC_S_FMT, &amp;vfmt); if(ret &lt; 0) &#123; perror(&quot;设置格式失败&quot;); &#125; //4.申请内核空间 struct v4l2_requestbuffers reqbuffer; reqbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; reqbuffer.count = 4; //申请4个缓冲区 reqbuffer.memory = V4L2_MEMORY_MMAP ;//映射方式 ret = ioctl(fd, VIDIOC_REQBUFS, &amp;reqbuffer); if(ret &lt; 0) &#123; perror(&quot;申请队列空间失败&quot;); &#125; //5.映射 unsigned char *mptr[4];//保存映射后用户空间的首地址 unsigned int size[4]; struct v4l2_buffer mapbuffer; //初始化type, index mapbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; for(int i=0; i&lt;4; i++) &#123; mapbuffer.index = i; ret = ioctl(fd, VIDIOC_QUERYBUF, &amp;mapbuffer);//从内核空间中查询一个空间做映射 if(ret &lt; 0) &#123; perror(&quot;查询内核空间队列失败&quot;); &#125; mptr[i] = (unsigned char *)mmap(NULL, mapbuffer.length, PROT_READ|PROT_WRITE, MAP_SHARED, fd, mapbuffer.m.offset); size[i]=mapbuffer.length; //通知使用完毕--‘放回去’ ret = ioctl(fd, VIDIOC_QBUF, &amp;mapbuffer); if(ret &lt; 0) &#123; perror(&quot;放回失败&quot;); &#125; &#125;//6.开始采集 int type = V4L2_BUF_TYPE_VIDEO_CAPTURE; ret = ioctl(fd, VIDIOC_STREAMON, &amp;type); if(ret &lt; 0) &#123; perror(&quot;开启失败&quot;); &#125; unsigned char rgbdata[640*480*6]; while(1) &#123; //从队列中提取一帧数据 struct v4l2_buffer readbuffer; readbuffer.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; ret = ioctl(fd, VIDIOC_DQBUF, &amp;readbuffer); if(ret &lt; 0) &#123; perror(&quot;提取数据失败&quot;); &#125; //FILE *file=fopen(&quot;my.jpg&quot;, &quot;w+&quot;); //mptr[readbuffer.index] //fwrite(mptr[readbuffer.index], readbuffer.length, 1, file); //fclose(file); read_JPEG_file(mptr[readbuffer.index], rgbdata, readbuffer.length); lcd_show_rgb(rgbdata, 640, 480); //通知内核已经使用完毕 ret = ioctl(fd, VIDIOC_QBUF, &amp;readbuffer); if(ret &lt; 0) &#123; perror(&quot;放回队列失败&quot;); &#125; &#125; ret = ioctl(fd, VIDIOC_STREAMOFF, &amp;type); for(int i=0; i&lt;4; i) &#123; munmap(mptr[i], size[i]); &#125; //9.关闭设备 close(fd); return 0;&#125;","tags":[{"name":"V4L2","slug":"V4L2","permalink":"https://zh-wiki.github.io/tags/V4L2/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Linux Driver","slug":"技术研发/Linux-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-Driver/"},{"name":"V4L2","slug":"技术研发/Linux-Driver/V4L2","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-Driver/V4L2/"}]},{"title":"Ubuntu 开发环境的搭建","date":"2019-12-31T16:00:00.000Z","path":"undefined/计算机基础知识/Ubuntu 开发环境的搭建/","text":"Samba 服务共享目录 添加以下配置 /etc/samba/smb.conf 123456[文件夹名] path = #目录路径 browseable = ye #可查看共享文件 guest ok = yes #所有人均可访问共享目录 writable = yes #允许写入 public = yes #允许匿名用户访问 配置结束重启服务 1sudo service smbd restart ubuntu18.04 virtualBox windows 支持usb 执行命令sudo usermod -aG vboxusers 用户名（让virtualbox 能识别到主机的usb） cat /etc/group | grep vboxusers （查看是否已经添加成功） 下载插件 下载链接. 下载插件比较慢，已经提前下载好的。适用于（virtualbox 5.2.34) 安装插件 设置 USB 协议的支持 reboot （重启ubuntu） 如果重启电脑之后，虚拟机可以扫描到USB设备，但是Ｗin7中提示驱动未能安装成功。解决方法：下载驱动精灵。安装USB驱动。 VirtualBox 修复’modprobe vboxdrv’ 报错 问题发生背景 Linux 内核版本升级之后，virtualbox 的驱动没有更新成功。 解决方法 a.更新整个系统 12sudo apt updatesudo apt upgrade b.重新安装对应内核版本的头文件,和virtualbox的驱动 1sudo apt install --reinstall linux-headers-$(uname -r) virtualbox-dkms dkms c.加载驱动重启 12sudo modprobe vboxdrvreboot 注意事项 更新驱动的时候，会重新编译驱动，所以要选择对应的gcc编译器，太老的估计会凉。 支持多版本的gcc 系统安装ok后默认gcc 版本是 v-7.x。我们先搞一个低版本的gcc 1234sudo apt-get install gcc-4.8sudo apt-get install g++-4.8sudo ln -sf /usr/bin/g++-4.8 /usr/bin/g++sudo ln -sf /usr/bin/gcc-4.8 /usr/bin/gcc 管理多个版本的gcc a.查看存在几个版本的gcc 1ls -l /usr/bin/gcc b.分别为gcc和g++添加管理组 12sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 40sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 40 c.能添加就能删除,从管理组中删除 1sudo update-alternatives --remove gcc /usr/bin/gcc-4.8 设置ok使用以下指令选择gcc的版本 12sudo update-alternatives --config gccsudo update-alternatives --config g++ 安装多版本的jdk 首先到官网下载jdk源码包 JDK官网 华为JDK网址 安装jdk 12sudo mkdir /usr/lib/jvmsudo tar -zxvf jdk-7u60-linux-x64.gz -C /usr/lib/jvm #//将jdk包复制到该目录进行解压 将jdk注册到系统方便多版本jdk进行切换 123#只需要将下面的命令中jdk的路径换为自己对应版本的路径就好了sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_191/bin/java 300sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_191/bin/javac 300 系统中切换jdk或者javac 12sudo update-alternatives --config javasudo update-alternatives --config javac Ubuntu查看端口和释放端口 查看所有端口：netstat -tln 查看指定端口：netstat -tln | grep 端口号 查看指定端口被那些进程占用：lsof -i :端口号 释放端口及就是杀死占用该端口的进程：kill -9 进程id Nginx 服务的搭建 常用命令 （/usr/local/nginx/sbin） 12sudo ./nginx suod ./nginx -s stop 查看ip的访问量 12cd /usr/local/nginx/logs/awk &#x27;&#123;cnt[$1]++;&#125;END&#123;for(i in cnt)&#123;printf(&quot;%s\\t%s\\n&quot;, cnt[i], i);&#125;&#125;&#x27; access.log|sort -n","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"}],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Ubuntu 中搭建gitlab服务器","date":"2019-12-31T16:00:00.000Z","path":"undefined/计算机基础知识/ubuntu 中搭建gitlab服务器/","text":"GitLab 服务器简介 什么是gitlab？ gitlab 和 githab 是一样的。只不过gitlab 适用于公司内部，服务器是搭建在本地的。有利于项目的保密。 为什么搭建gitlab, 有什么作用？ 我们现在使用的wiki知识系统，用的是一种比较粗暴的手段，每个人都可以提交。提交进去就会直接入库。只能通过git log 查看提交记录。 时间长了不方便管理。对每个人的权限不好进行管控。 gitlab 有点类似我们日常工作的gerrit. 可以管理我们每个人的权限 管理项目的分支。方便查看提交记录。 可以指定管理员进行管理每笔提交是否进行合入 GitLab 的搭建 安装依赖包 1sudo apt-get install curl openssh-server ca-certificates postfix 添加镜像源 123vi /etc/apt/sources.list.d/gitlab-ce.list#添加以下内容deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu xenial main 安装gitlab-ce 12sudo apt-get updatesudo apt-get install gitlab-ce gitlab 常用命令 123sudo gitlab-ctl startsudo gitlab-ctl stopsudo gitlab-ctl restart gitlab 比较耗费系统资源，所以不要在自己的电脑上进行操作。最好找一台服务器。 GitLab 的使用 注册账户请严格按照以下格式进行填写 Username ：华勤员工工号 Email：公司邮箱地址 个人设置点击右上方用户图标进入设置界面 配置以下内容 ssh 配置（必须配置） 语言（中文）偏好设置的最下方 标题栏 管理员配置管理员可以很好的管理自己项目，用户，以及组别 创建团队 点击上图Groups 下方的 New group 即可创建团队 创建项目 点击上图中的新建项目 项目成员管理 可以指定项目成员，成员角色，访问日期 研发工作 管理员创建好项目，将组员添加好之后，组员们登录自己用户会看到该项目。 组员需要将该项目派生到自己的项目中。应该在项目列表中会发现有两个相同的项目，但是owner不一样。 克隆自己派生出来的那一套到自己的电脑本地。以后我们就是在这套代码上进行修改了。修改后提交代码。正常的git 操作 确认没问题之后，提交merge请求。 完善请求信息指定reviewer 信息填写ok ，之后可以submit .当然也可一check一下自己的更改 开发者指定的review者会收到消息 review 可以check一下相关内容，没什么问题，可以合并。也可以点赞，加评论鼓舞士气。 项目派生的简介 管理员创建好项目默认是master分支，除了管理员其他人一律不能push, 只能是通过merge. 所以说开发者必须在该项目的基础上派生一个出来。单独开发(可以理解为不同的用户创建不同的专属分支) 这样的话，既不会影响基线上的项目，也不会影响别人的分支。你只是在自己派生出来的这个项目上折腾。 那么问题来了，比如说管理员创建一个项目。甲和乙同事派生的项目。 甲提交代码入库了。 此时乙的代码已经不是最新了。即使你 git pull 也是拉的你派生的代码，并不是基线上的。执行一下指令，发现本地只有自己派生出来的远程分支，那么我们只要添加管理员创建的远程分支就好了. 回到你项目的主页，会发现有两个同名的项目。点开管理员创建的那个。点击克隆。把ssh地址复制。 123456git remote add upstream xxxxxx #添加远程分支git remote -v #增加了一条远程分支git fetch upstream #获取最新的基线代码git merge upstream/master #将基线代码合入你本地分支git push origin master #将最新的代码提交到你派生的项目中#这时候你 本地代码 和你 远程派生的代码 还有 基线代码 是保持最新的同步的。 ok ,现在就可以在最新的基础上修改了。","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"}],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Android 研发总结","date":"2019-12-31T16:00:00.000Z","path":"undefined/技术研发/Android 研发总结/经验总结/","text":"在makefile中添加条件判断 如果 TARGET_PRODUCT 等于 lime 或者 citrus 就走if 否则走 else 12345ifeq ($(TARGET_PRODUCT), $(filter $(TARGET_PRODUCT), lime citrus))COMPOSER_TARGET_INPUT := $(CAMX_PATH)/src/settings/$(TARGET_PRODUCT)/camxsettings.xmlelseCOMPOSER_TARGET_INPUT := $(CAMX_PATH)/src/settings/$(TARGET_BOARD_PLATFORM)/camxsettings.xmlendif 在makefile添加打印log 1234#打印字符串$(warning &quot;wocao&quot;)#打印变量$(warning $(变量名)) 如何编译 selinux 编译命令 1make selinux_policy 生成的文件 path : out/target/product/lime/vendor/etc/selinux 如何将最近指定时间(45min)内生成的文件 push 到 指定 的路径 1find . -mmin -45 -type f|grep -v SHARED_LIBRARIES|grep -v STATIC_LIBRARIES|grep -Ei &quot;so|bin&quot;|grep -v symbols|xargs -t -I &#x27;&#123;&#125;&#x27; adb push &#123;&#125; /vendor/lib64/&#123;&#125; 如何在安卓中自定义 log 12#include &lt;android/log.h&gt; #define GC02M1B_DBG(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, &quot;GC02M1B&quot;,fmt, ##args) Trace 的使用 systrace.py 的路径 path：项目代码/native/external/chromium-trace 如何打开 trace 的 html 在谷歌浏览器输入 chrome://tracing/","tags":[{"name":"Android","slug":"Android","permalink":"https://zh-wiki.github.io/tags/Android/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Android 研发总结","slug":"技术研发/Android-研发总结","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Android-%E7%A0%94%E5%8F%91%E6%80%BB%E7%BB%93/"}]},{"title":"ADB 常用命令","date":"2019-12-31T16:00:00.000Z","path":"undefined/技术研发/Linux 命令/ADB 常用命令/","text":"通用命令检测usb设备1adb wait-for-usb-device 属性相关123adb shell setprop 属性名adb shell getpropadb shell getprop | grep -i xxx 安装与卸载apk123adb install xxx.apkadb uninstall com.xxx.xxxadb shell pm list packages | grep xxx 设置屏幕1adb shell input keyevent 26 Cam相关指令dump camera的相关信息1adb shell dumpsys media.camera &gt; cam 查看camera个数1watch -n 1 -d &quot;adb shell dumpsys media.camera|grep Number&quot; 打开摄像头1adb shell am start -a android.media.action.STILL_IMAGE_CAMERA 打开前置摄像头1adb shell am start -a android.media.action.IMAGE_CAPTURE --ei android.intent.extras.CAMERA_FACING 1 高通平台 Camera 相关开启高通相机选择camera id1adb shell setprop persist.sys.camera.devoption.debug 100 使能多摄像1adb shell setprop persist.vendor.camera.multicam 1 开启支持多摄的权限123adb shell setprop vendor.camera.aux.packagelist org.codeaurora.snapcamadb shell setprop persist.vendor.camera.privapp.list org.codeaurora.snapcamadb shell setprop vendor.camera.aux.packagelist &quot;org.codeaurora.snapcam,com.huaqin.cameraautotest,com.huaqin.factory&quot; 高通 Camx 杀死 camera 进程1adb shell ps -A|grep camera |awk &#x27;&#123;print $2&#125;&#x27;|xargs adb shell kill -9 命令解释: awk ‘{print $2}’ 这个命令会把 ps -A | grep camera 得出的进程id 输出到终端 （$2 是第二字段也就是 进程id） xargs adb shell kill -9 这个命令会把 awk 获取到的线程id 当做参数传递给 kill -9 这个命令 高通 Camx dump metadata1adb shell dumpsys media.camera &gt;meta.log ADB 常见问题ADB 连接不上报以下错误 解决方法： 12cd /etc/udev/rules.dsudo vim 51-android.rules 在文件中写入：SUBSYSTEM==”usb”, ENV{DEVTYPE}==”usb_device”, MODE=”0666”","tags":[],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Linux 命令","slug":"技术研发/Linux-命令","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"}]},{"title":"小米J19S项目随笔","date":"2019-12-31T16:00:00.000Z","path":"undefined/技术研发/项目随笔/小米J19S项目随笔/","text":"项目相关 平台 高通 smd6115 camx 架构 工模测试后辐全不亮解决方法：添加CameraAutoTest 相机权限 路径：device/qcom/qssi/system.prop 12 #Expose aux camera for below packagesvendor.camera.aux.packagelist=org.codeaurora.snapcam,com.huaqin.cameraautotest,com.huaqin.factory 路径：device/xiaomi/lime/system.prop 12#Expose aux camera for below packagesvendor.camera.aux.packagelist=org.codeaurora.snapcam,com.huaqin.cameraautotest,com.huaqin.factory 通过getprop 属性区分主二供方案 module xml 中的 vendorName 配置为：如 sunny_i 或者 sunny_ii ,分别代表主供和二供 将camx解析到的数据传递给chi 在chi中logicalId映射的位置设置属性 实现方法camx 和 chi 的通信 1234567//chxextensionmodule.cppExtensionModule::ExtensionModule()&#123; //这个就是函数接口的映射，核心就在这个全局句柄 g_chiContextOps PCHIENTRY funcPChiEntry = reinterpret_cast&lt;PCHIENTRY&gt;(ChxUtils::LibGetAddr(handle, &quot;ChiEntry&quot;)); funcPChiEntry(&amp;g_chiContextOps);&#125; 12345678910111213//vendor/qcom/proprietary/camx/src/core/chi/camxchi.cppCAMX_VISIBILITY_PUBLIC VOID ChiEntry( ChiContextOps* pChiContextOps)&#123; if (NULL != pChiContextOps) &#123; pChiContextOps-&gt;size = sizeof(ChiContextOps); pChiContextOps-&gt;majorVersion = CHI_API_MAJOR_VERSION; pChiContextOps-&gt;pGetNumCameras = CamX::ChiGetNumCameras; pChiContextOps-&gt;pGetCameraInfo = CamX::ChiGetCameraInfo; pChiContextOps-&gt;pGetModuleName = CamX::ChiGetModuleName; &#125; 很显然如果要扩展功能只需要在ChiContextOps 这个结构体中add一个接口指针。在camxchi.cpp 这个文件中实现改方法，然后在ChiEntry()中进行指针映射。具体方法的实现可以参考别的接口。 针对该需要我实现的接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//chxextensionmodule.cppCDKResult ExtensionModule::EnumerateCameras()&#123; result &amp;= g_chiContextOps.pGetModuleName(m_hCHIContext, i, pModuleName); SetPersistCameraModuleInfo(cameraInfo.sensorCaps.pSensorName, pModuleName);&#125;//chxextensionmodule.cppCDKResult ExtensionModule::SetPersistCameraModuleInfo(CHAR* sensor_name, CHAR* module_name)&#123; char buf[50]=&#123;0&#125;; char name_buf[50]=&#123;0&#125;; char prop_buf[50]=&quot;persist.vendor.camera.&quot;; char *pstr,*pstr_save; if((!sensor_name) || (!module_name)) return CDKResultEFailed; CHX_LOG_INFO(&quot;sensor_name %s module_name %s&quot;,sensor_name,module_name); strcpy(buf, sensor_name); pstr = strchr(buf, &#x27;_&#x27;); if(!pstr) return CDKResultEFailed; snprintf(name_buf, strlen(pstr), &quot;%s&quot;, &amp;pstr[1]); while(pstr) &#123; pstr++; pstr_save = pstr; pstr = strchr(pstr,&#x27;_&#x27;); &#125; strcat(prop_buf, pstr_save); memset(buf,0,sizeof(buf)); strcpy(buf, module_name); pstr = strchr(buf, &#x27;_&#x27;); if(!pstr) return CDKResultEFailed; strcat(name_buf, pstr); if(property_set(prop_buf, name_buf) &lt; 0) &#123; CHX_LOG_ERROR(&quot;property_set is error&quot;); return CDKResultEFailed; &#125; CHX_LOG_INFO(&quot;property_set is success&quot;); return CDKResultSuccess;&#125;//vendor/qcom/proprietary/camx/src/core/chi/camxchi.cppstatic CDKResult ChiGetModuleName( CHIHANDLE hChiContext, UINT32 cameraId, CHAR* pModuleName)&#123; CDKResult result = CDKResultSuccess; ChiContext* pChiContext = GetChiContext(hChiContext); /// @todo (CAMX-2491) CDKResult to CamxResult result = pChiContext-&gt;GetModuleName(cameraId, pModuleName); return result;&#125;//vendor/qcom/proprietary/camx/src/core/chi/camxchicontext.cppCamxResult ChiContext::GetModuleName( UINT32 cameraId, CHAR* pModuleName)&#123; CamxResult result = CamxResultSuccess; if ((cameraId &lt; GetNumCameras())) &#123; ImageSensorModuleData* pImageSensorModuleData = // NOWHINE CP036a: Since the function is const, had to add the const_cast const_cast&lt;ImageSensorModuleData*&gt;(m_pHwEnvironment-&gt;GetImageSensorModuleData(cameraId)); pImageSensorModuleData-&gt;GetModuleName(pModuleName); &#125; else &#123; CAMX_LOG_WARN(CamxLogGroupHAL, &quot;Invalid arguments cameraId = %d, m_numImageSensors = %d&quot;, cameraId, GetNumCameras()); result = CamxResultEInvalidArg; &#125; return result;&#125;//vendor/qcom/proprietary/camx/src/core/camximagesensormoduledata.cppCamxResult ImageSensorModuleData::GetModuleName( CHAR* pModuleName ) const&#123; CamxResult result = CamxResultSuccess; if (NULL != m_pCameraModuleData-&gt;moduleGroup.moduleConfiguration) &#123; strcpy(pModuleName, m_pCameraModuleData-&gt;moduleGroup.moduleConfiguration[m_usedModuleId].moduleName); &#125; else &#123; CAMX_LOG_ERROR(CamxLogGroupSensor, &quot;m_pCameraModuleData-&gt;moduleGroup.moduleConfiguration is NULL&quot;); result = CamxResultEInvalidPointer; &#125; return result;&#125; setprop 属性不成功-权限问题 这个文件中我认为是定义prop的样式，属性名类似与 vendor.camera.xxx， 后面的 _prop 应该是默认格式必须加 123#路径：device/qcom/sepolicy/generic/vendor/common/property.te#camera fuseidtype vendor_camera_fuseid_prop, property_type; 引用前面的类型，定义属性前缀并设置权限 123#路径：device/qcom/sepolicy/generic/vendor/common/property_contexts#vendor-cameravendor.camera.sensor. u:object_r:vendor_camera_fuseid_prop:s0 引用前面两个定义，使其生效 12#路径：device/qcom/sepolicy/generic/vendor/common/hal_camera.teset_prop(hal_camera, vendor_camera_fuseid_prop) 帧率问题人像模式在暗环境，帧率过低，预览卡顿 首先确认一下信息 测试环境有多暗 lux（是否有量变的过程） camera 镜头距离拍摄物多远 查看sensor 出帧是否正常 开启内核双摄帧同步的log 12adb shell &quot;echo 0x1000018 &gt; ./sys/module/cam_debug_util/parameters/debug_mdl&quot;adb logcat -b kernel &gt; kmd.log 正常环境log 1234Line 3662: 01-02 02:37:40.256 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:64 frame number:66 SOF time stamp:0x4ceb8d14a14Line 3679: 01-02 02:37:40.256 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:64 frame number:66 SOF time stamp:0x4ceb8d5cc41Line 4564: 01-02 02:37:40.289 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:65 frame number:67 SOF time stamp:0x4cebacd4843Line 4618: 01-02 02:37:40.290 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:65 frame number:67 SOF time stamp:0x4cebad1caa4 通过上述log，发现 request id 和 frame number 都是成双成对的。分别对应主摄和辅摄的出帧。 For Example ：request id:65 frame number:67 Line 4564: 01-02 02:37:40.289 Line 4618: 01-02 02:37:40.290 通过分析log ，可以看出主摄和辅摄只差1ms，同步OK. 暗环境下的log 12345Line 124973: 01-02 03:00:15.035 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:193 SOF time stamp:0x60a27f1067bLine 124990: 01-02 03:00:15.035 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:110 SOF time stamp:0x60a27f5890fLine 131018: 01-02 03:00:16.055 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:0 frame number:213 SOF time stamp:0x60a64afe776Line 131041: 01-02 03:00:16.055 0 0 I CAM_DBG : CAM-ISP: __cam_isp_ctx_send_sof_timestamp: 666: request id:74 frame number:121 SOF time stamp:0x60a64b469d7 很明显没有同步，分别算一下帧率 16.055 - 15.035 = 1.5s 主摄 (213-193)/1.5 = 13fps 辐射 (121-110)/1.5 = 7.3fps 解决方法 方案一 找Tuning的同事固定帧率，调试曝光表","tags":[{"name":"项目随笔","slug":"项目随笔","permalink":"https://zh-wiki.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"项目随笔","slug":"技术研发/项目随笔","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"}]},{"title":"MarkDown 常用语法","date":"2019-12-31T16:00:00.000Z","path":"undefined/程序语言/MarkDown/MarkDown 常用语法/","text":"MarkDown 插入音频1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;音频地址&quot;&gt;&lt;/iframe&gt; MarkDown 插入视频1&lt;iframe height=498 width=510 src=&quot;视频地址&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt; 插入代码折叠片段12345678&lt;details&gt;&lt;summary&gt;标签名&lt;/summary&gt;``````&lt;/details&gt;","tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://zh-wiki.github.io/tags/MarkDown/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"MarkDown","slug":"程序语言/MarkDown","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/MarkDown/"}]},{"title":"高通 Camx 介绍","date":"2019-12-31T16:00:00.000Z","path":"undefined/技术研发/Camera Driver/高通 Camx/高通 Camx 介绍/","text":"概览Camx-CHI 整体框架如下 其中 camx 代表了通用功能性接口的代码实现集合，chi-cdk代表了可定制化需求的代码实现集合，从图中不难看出camx部分对上作为HAL3接口的实现,对下通过v4l2框架与Kernel保持通讯,中间通过互相dlopen so库并获取对方操作接口的方式保持着与CHI的交互。 camx/中有如下几个主要目录: core/ : 用于存放camx的核心实现模块,其中还包含了主要用于实现hal3接口的hal/目录,以及负责与CHI进行交互的chi/目录 csl/: 用于存放主要负责camx与camera driver的通讯模块,为camx提供了统一的Camera driver控制接口 hwl/: 用于存放自身具有独立运算能力的硬件node,该部分node受csl管理 swl/: 用于存放自身并不具有独立运算能力,必须依靠CPU才能实现的node chi-cdk/中有如下几个主要目录: chioverride/: 用于存放CHI实现的核心模块,负责与camx进行交互并且实现了CHI的总体框架以及具体的业务处理。 bin/: 用于存放平台相关的配置项 topology/: 用于存放用户自定的Usecase xml配置文件 node/: 用于存放用户自定义功能的node module/: 用于存放不同sensor的配置文件,该部分在初始化sensor的时候需要用到 tuning/: 用于存放不同场景下的效果参数的配置文件 sensor/: 用于存放不同sensor的自有信息以及寄存器配置参数 actuator/: 用于存放不同对焦模块的配置信息 ois/: 用于存放防抖模块的配置信息 flash/: 存放着闪光灯模块的配置信息 eeprom/: 存放着eeprom外部存储模块的配置信息 fd/: 存放了人脸识别模块的配置信息","tags":[{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"}]},{"title":"从零实现虚拟Camera Driver","date":"2019-12-31T16:00:00.000Z","path":"undefined/技术研发/Linux Driver/V4L2/从零写虚拟v4l2驱动/","text":"注册 Video Device 实现字符设备驱动的基本骨架1234567891011121314151617#include &lt;linux/module.h&gt;#include &lt;media/v4l2-device.h&gt;static int __init my_camera_init(void)&#123; int ret; return ret;&#125;static void __exit my_camera_exit(void)&#123;&#125;module_init(my_camera_init);module_exit(my_camera_exit);MODULE_LICENSE(&quot;GPL&quot;); 注册video device 分配一个 video_device结构体 配置注册video_device的必要条件 注册 video_device 12345678910111213141516171819202122232425262728static struct video_device *my_camera_dev;static struct v4l2_device v4l2_dev;static const struct v4l2_file_operations my_camera_fops =&#123; .owner = THIS_MODULE,&#125;;static void my_camera_dev_release(struct video_device *vdev)&#123; &#125;static int __init my_camera_init(void)&#123; int ret; /* 1.分配一个video_device结构体 */ my_camera_dev = video_device_alloc(); /* 2.设置 */ my_camera_dev-&gt;release = my_camera_dev_release; my_camera_dev-&gt;fops = &amp;my_camera_fops; my_camera_dev-&gt;v4l2_dev = &amp;v4l2_dev; /* 3.注册 */ ret = video_register_device(my_camera_dev, VFL_TYPE_GRABBER, -1); return ret;&#125; 验证1234sudo modprobe vividsudo rmmod vividsudo insmod my_camera.kols /dev/*video*","tags":[{"name":"V4L2","slug":"V4L2","permalink":"https://zh-wiki.github.io/tags/V4L2/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Linux Driver","slug":"技术研发/Linux-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-Driver/"},{"name":"V4L2","slug":"技术研发/Linux-Driver/V4L2","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-Driver/V4L2/"}]},{"title":"工厂模式","date":"2019-12-31T16:00:00.000Z","path":"undefined/程序语言/C++/设计模式/工厂模式/","text":"简单工厂模式 基本结构 工厂类：用于创建和实现所有具体实例 抽象类：基类，所有实例的父类，用于实现所有实例的公共接口 具体实例：继承于抽象类的具体实例 代码验证 抽象类 定义1个水果类，实现所有水果的公共接口(获取水果名称) 1234567class Fruit&#123;public: virtual void getFruit() = 0;protected:private:&#125;; 具体厂品实例 继承抽象类，定义苹果和香蕉的具体实例，分别实现继承于基类的公共接口 123456789101112131415161718192021class Banana : public Fruit&#123;public: virtual void getFruit() &#123; cout &lt;&lt; &quot;Banana&quot;&lt;&lt;endl; &#125;protected:private: &#125;;class Apple : public Fruit&#123;public: virtual void getFruit() &#123; cout &lt;&lt; &quot;Apple&quot;&lt;&lt;endl; &#125;protected:private: &#125;; 工厂类 实现创建各个产品实例 注意： 函数原型返回类型：基类 函数返回：子类 1234567891011121314151617181920class Factory&#123;public: Fruit *create(char *p) &#123; if(strcmp(p, &quot;banana&quot;) == 0) &#123; return new Banana; &#125; else if(strcmp(p, &quot;apple&quot;) == 0) &#123; return new Apple; &#125; else &#123; cout &lt;&lt;&quot;invalid&quot;&lt;&lt;endl; return NULL; &#125; &#125;&#125;; 应用 1234567891011121314151617#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; Factory *f = new Factory; Fruit *fruit = NULL; fruit = f-&gt;create(&quot;banana&quot;); fruit-&gt;getFruit(); delete f; fruit = f-&gt;create(&quot;apple&quot;); fruit-&gt;getFruit(); delete f;&#125; 总节简单工程模式不属于标准的设计模式，不能实现高内聚，增加具体产品实例需要修改工厂类，工厂类的代码逻辑惠逐渐变的庞大。 工厂模式 争对于简单工厂模式的不足，工厂模式做了以下优化。将工厂模式也抽象出来，需要创建什么产品实例，首先创建其对应工厂，然后创建其产品实例。 基本结构 工厂抽象类：所有工厂的基类，实现工厂的公共接口 产品抽象类：基类，所有实例的父类，用于实现所有实例的公共接口 产品工厂实例：继承于工厂抽象类，创建具体产品实例 产品实例：继承于抽象类的具体实例 代码验证 产品抽象类 1234567class Fruit&#123;public: virtual void getFruit() = 0;protected:private:&#125;; 工厂抽象类 用于创建水果类的抽象工厂 12345class abFactory&#123;public: virtual Fruit* creatproduct() = 0;&#125;; 产品实例 123456789101112131415161718192021class Banana : public Fruit&#123;public: virtual void getFruit() &#123; cout &lt;&lt; &quot;Banana&quot;&lt;&lt;endl; &#125;protected:private: &#125;;class Apple : public Fruit&#123;public: virtual void getFruit() &#123; cout &lt;&lt; &quot;Apple&quot;&lt;&lt;endl; &#125;protected:private: &#125;; 产品工厂实例 继承抽象工厂，实现具体产品工厂 1234567891011121314151617class BananaFactory : public abFactory&#123;public: virtual Fruit* creatproduct() &#123; return new Banana; &#125;&#125;;class AppleFactory : public abFactory&#123;public: virtual Fruit* creatproduct() &#123; return new Apple; &#125;&#125;; 应用 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; abFactory *factory = NULL; Fruit *fruit = NULL; factory = new BananaFactory; fruit = factory-&gt;creatproduct(); fruit-&gt;getFruit(); delete factory; delete fruit; factory = new AppleFactory; fruit = factory-&gt;creatproduct(); fruit-&gt;getFruit(); delete factory; delete fruit;&#125; 总结工厂模式只能生产一个产品，要么香蕉要么苹果，不能生产一个产品族。 抽象工厂模式 要想工厂能生产一系列产品，只需要在 抽象工厂类中增加接口即可, 子类继承的时，实例化具体接口。 1234567class abFactory&#123;public: virtual Fruit* creatproductA() = 0; virtual Fruit* creatproductB() = 0; virtual Fruit* creatproductC() = 0;&#125;;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://zh-wiki.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"程序语言","slug":"程序语言","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"C++","slug":"程序语言/C","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"设计模式","slug":"程序语言/C/设计模式","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"高通 mm ConfigureStream 代码流程","date":"2019-11-29T16:00:04.000Z","path":"undefined/技术研发/Camera Driver/高通 MM/高通 mm ConfigureStream 代码流程/","text":"HAL Configure Stream 主要函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int QCamera3HardwareInterface::configureStreamsPerfLocked(camera3_stream_configuration_t *streamList)&#123; ...... /* stream configurations */ for (size_t i = 0; i &lt; streamList-&gt;num_streams; i++) &#123; camera3_stream_t *newStream = streamList-&gt;streams[i]; ...... //根据不同的格式 给局部变量赋值，暂时先不研究 ...... &#125; camera3_stream_t *zslStream = NULL; //Only use this for size and not actual handle! for (size_t i = 0; i &lt; streamList-&gt;num_streams; i++) &#123; ....... //给类成员 mStreamInfo 复值 mStreamInfo.push_back(stream_info); ....... &#125; //Create metadata channel and initialize it //创建了metadata 的通道，并进行了初始化 mMetadataChannel = new QCamera3MetadataChannel(mCameraHandle-&gt;camera_handle, mChannelHandle, mCameraHandle-&gt;ops, captureResultCb, setBufferErrorStatus, &amp;padding_info, metadataFeatureMask, this); rc = mMetadataChannel-&gt;initialize(IS_TYPE_NONE); /* Allocate channel objects for the requested streams */ for (size_t i = 0; i &lt; streamList-&gt;num_streams; i++) &#123; ...... //这个循环可以理解为2部分 //第一部分 //很多地方操作了 mStreamConfigInfo 这个类成员，应该是配置流的某些配置信息 //第二部分 //为请求的流分配 chanel 对象，但是并没有初始化，我大概搂了一眼，操作和metadata channel操作都是差不多的 //只不过metadata channel 在配流的时候就初始化好了 //流的channel只是 new 了一个对象，在 request的时候初始化的。 if (newStream-&gt;priv == NULL) &#123; //New stream, construct channel switch (newStream-&gt;format) &#123; case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED: channel = new QCamera3RegularChannel(......); ........ newStream-&gt;max_buffers = MAX_INFLIGHT_HFR_REQUESTS; newStream-&gt;priv = channel; ........ break; &#125; ...... //创建成功之后，将各个channel存入 mStreamInfo list 中。大概浏览了一下 request 时候会调用，进行给channel初始化 for (List&lt;stream_info_t*&gt;::iterator it=mStreamInfo.begin(); it != mStreamInfo.end(); it++) &#123; if ((*it)-&gt;stream == newStream) &#123; (*it)-&gt;channel = (QCamera3ProcessingChannel*) newStream-&gt;priv; break; &#125; &#125; ....... &#125; &#125;&#125;","tags":[{"name":"高通 mm","slug":"高通-mm","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9A-mm/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 MM","slug":"技术研发/Camera-Driver/高通-MM","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-MM/"}]},{"title":"高通 mm INIT 代码流程","date":"2019-11-29T16:00:02.000Z","path":"undefined/技术研发/Camera Driver/高通 MM/高通 mm INIT 代码流程/","text":"Camera INIT 流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//vendor/qcom/proprietary/mm-camera/mm-camera2/server-imaging/server.cint main(int argc __unused, char *argv[] __unused)&#123; /* 2. after open node, initialize modules */ if(server_process_module_sensor_init() == FALSE) goto module_init_fail; CLOGD(CAM_MCT_MODULE, &quot;CAMERA_DAEMON:End of all modules init&quot;);&#125;//vendor/qcom/proprietary/mm-camera/mm-camera2/server-imaging/server_process.cboolean server_process_module_sensor_init(void)&#123; CLOGD(CAM_MCT_MODULE, &quot;CAMERA_DAEMON: Begin sensor init mods&quot;); if( NULL == modules_list[0].init_mod) return FALSE; //这里用了一个转移表 temp = modules_list[0].init_mod(modules_list[0].name);&#125;//vendor/qcom/proprietary/mm-camera/mm-camera2/server-imaging/server_process.c//转移表定义如下static mct_module_init_name_t modules_list[] = &#123; &#123;&quot;sensor&quot;, module_sensor_init, module_sensor_deinit, NULL&#125;, &#123;&quot;iface&quot;, module_iface_init, module_iface_deinit, NULL&#125;, &#123;&quot;isp&quot;, module_isp_init, module_isp_deinit, NULL&#125;, &#123;&quot;stats&quot;, stats_module_init, stats_module_deinit, NULL&#125;, &#123;&quot;pproc&quot;, pproc_module_init, pproc_module_deinit, NULL&#125;, &#123;&quot;imglib&quot;, module_imglib_init, module_imglib_deinit, NULL&#125;,&#125;;//vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/sensors/module/module_sensor.cmct_module_t *module_sensor_init(const char *name)&#123; /* module_sensor_probe_sensors */ ret = sensor_init_probe(module_ctrl); if (ret == FALSE) &#123; SERR(&quot;failed&quot;); goto ERROR1; &#125;&#125;//vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/sensors/module/sensor_init.c//这个函数已经干到内核了boolean sensor_init_probe(module_sensor_ctrl_t *module_ctrl)&#123; /* Open sensor_init subdev */ SINFO(&quot;opening: %s&quot;, subdev_name); sd_fd = open(subdev_name, O_RDWR); if (sd_fd &lt; 0) &#123; SHIGH(&quot;Open sensor_init subdev failed&quot;); return FALSE; &#125; ret = sensor_init_eebin_probe(module_ctrl, sd_fd); if (ret == FALSE) &#123; SINFO(&quot;failed: to probe eeprom bin sensors (non-fatal)&quot;); &#125; RETURN_ON_FALSE(sensor_init_xml_probe(module_ctrl, sd_fd));&#125;","tags":[{"name":"高通 mm","slug":"高通-mm","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9A-mm/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 MM","slug":"技术研发/Camera-Driver/高通-MM","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-MM/"}]},{"title":"MTK Camera 架构介绍","date":"2019-11-29T16:00:01.000Z","path":"undefined/技术研发/Camera Driver/MTK 平台/MTK Camera 架构介绍/","text":"","tags":[{"name":"MTK Camera","slug":"MTK-Camera","permalink":"https://zh-wiki.github.io/tags/MTK-Camera/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"MTK 平台","slug":"技术研发/Camera-Driver/MTK-平台","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/MTK-%E5%B9%B3%E5%8F%B0/"}]},{"title":"高通 mm 架构 bring up","date":"2019-11-29T16:00:01.000Z","path":"undefined/技术研发/Camera Driver/高通 MM/高通 mm 架构 bring up/","text":"PDAF 调试方法 首先设置号相应的log权限 12adb shell setprop persist.camera.stats.af.debug 5adb shell setprop persist.camera.stats.haf.debug 5 使相机进入fullsweep(全扫描)模式 1adb shell setprop vendor.debug.camera.af_fullsweep 1 可能不同的平台命令有所不同，可以在代码中搜索 123456789101112//vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/stats/q3a/af/af_biz.cvoid af_biz_process(stats_af_t *stats, af_output_data_t *output, uint8_t num_of_outputs, void *af_obj) &#123; // Get Setproc for fullsweep algo. /* Enable full-sweep property: * 0 - disable * 1 - far-to-near * 2 - reverse search (near-to-far) * 3 - both (far-&gt;near-&gt;far)*/ property_get(&quot;vendor.debug.camera.af_fullsweep&quot;, value, &quot;0&quot;); &#125; log 分析 123456789101112Line 86657: 01-03 07:11:00.426 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=438 index=14, pd=-10.02, defocus(um)=-248, conf=537, is_conf=FALSE, not_conf_cnt=13, is_stable=TRUELine 88565: 01-03 07:11:00.504 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=438 index=16, pd=-10.24, defocus(um)=-253, conf=559, is_conf=FALSE, not_conf_cnt=15, is_stable=TRUELine 94865: 01-03 07:11:00.769 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=434 index=22, pd=-10.55, defocus(um)=-262, conf=532, is_conf=FALSE, not_conf_cnt=21, is_stable=TRUELine 98620: 01-03 07:11:00.905 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=432 index=26, pd=-10.45, defocus(um)=-259, conf=547, is_conf=FALSE, not_conf_cnt=25, is_stable=TRUE..................Line 692125: 01-03 07:11:35.301 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=4 index=34, pd=6.69, defocus(um)=166, conf=916, is_conf=FALSE, not_conf_cnt=259, is_stable=TRUELine 694909: 01-03 07:11:35.424 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=2 index=37, pd=6.72, defocus(um)=166, conf=917, is_conf=FALSE, not_conf_cnt=262, is_stable=TRUELine 697981: 01-03 07:11:35.661 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=0 index=43, pd=6.83, defocus(um)=169, conf=945, is_conf=FALSE, not_conf_cnt=268, is_stable=TRUE.................Line 1000442: 01-03 07:11:53.425 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=166 index=36, pd=-0.06, defocus(um)=-1, conf=705, is_conf=TRUE, not_conf_cnt=0, is_stable=TRUELine 1001078: 01-03 07:11:53.460 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=166 index=37, pd=0.05, defocus(um)=1, conf=695, is_conf=TRUE, not_conf_cnt=0, is_stable=TRUELine 1001836: 01-03 07:11:53.503 681 4760 D mm-camera: &lt;STATS_HAF &gt;&lt; HIGH&gt; 3586: af_pdaf_proc_pd_single: roi(0) lens_pos=166 index=38, pd=0.15, defocus(um)=3, conf=731, is_conf=TRUE, not_conf_cnt=0, is_stable=TRUE 进入fullsweep Mode Far to Near 进行完一次全扫描后，lens position 最终是 166，观察pd值 和 defocus 接近于0 表示正常 过程中观察 pd 和 defocus 值应该是成线性的 Dump OTP 数据 如果camera文件夹在vendor路径下 1234adb rootadb remountadb shell setprop persist.vendor.camera.cal.dump 1adb reboot dump 的数据路径如下 双摄帧同步导通 sensor setting 的配置 主摄配置 12345678910111213141516171819202122//vendor/qcom/proprietary/mm-camera/mm-camera2/media-controller/modules/sensors/sensor/libs/hi1336_hs70_hlt/hi1336_lib.h#define DUAL_CAM_MASTER_SETTINGS \\&#123; \\ &#123;0x0250, 0x0100, 0x0000&#125;, \\ &#123;0x0254, 0x1c00, 0x0000&#125;, \\ &#123;0x0256, 0x0000, 0x0000&#125;, \\ &#123;0x0258, 0x0001, 0x0000&#125;, \\ &#123;0x025A, 0x0000, 0x0000&#125;, \\ &#123;0x025C, 0x0000, 0x0000&#125;, \\&#125;static sensor_lib_t sensor_lib_ptr =&#123; .dualcam_master_settings = &#123; .reg_setting_a = DUAL_CAM_MASTER_SETTINGS, .addr_type = CAMERA_I2C_WORD_ADDR, .data_type = CAMERA_I2C_WORD_DATA, .delay = 0, .size = 6, &#125;,&#125; 辅摄配置 123456789101112131415161718192021#define DUAL_CAM_SLAVE_SETTINGS \\&#123; \\ &#123;0x3002, 0x00, 0x00&#125;, \\ &#123;0x3823, 0x30, 0x00&#125;, \\ &#123;0x3824, 0x00, 0x00&#125;, \\ &#123;0x3825, 0x20, 0x00&#125;, \\ &#123;0x3826, 0x00, 0x00&#125;, \\ &#123;0x3827, 0x04, 0x00&#125;, \\&#125;static sensor_lib_t sensor_lib_ptr =&#123; .dualcam_slave_settings = &#123; .reg_setting_a = DUAL_CAM_SLAVE_SETTINGS, .addr_type = CAMERA_I2C_WORD_ADDR, .data_type = CAMERA_I2C_BYTE_DATA, .delay = 0, .size = 6, &#125;,&#125; Dump MetaData dump metadata 的命令 1adb shell dumpsys media.camera &gt; cameraservice_dump.txt 动态查看metadata 1watch -d -n 0.1 &quot;adb shell dumpsys media.camera |grep &#x27;aeTargetFpsRange&#x27; -A 3&quot;","tags":[{"name":"高通 mm","slug":"高通-mm","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9A-mm/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 MM","slug":"技术研发/Camera-Driver/高通-MM","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-MM/"}]},{"title":"XTS 测试指南","date":"2019-11-29T16:00:00.000Z","path":"undefined/技术研发/XTS 相关/XTS 测试指南/","text":"CTS 简介 描述通过Google CTS兼容性测试工具，对安卓系统进行测试，检查系统是否符合兼容性规范，找出系统兼容性问题，提升系统稳定性。 APP 层与 Framework 层在设计上是分开的， 但通过 CTS 测试，确保了 APP 与 Android Framework 之间有一致的调用接口（API），这使得 APP 开发者编写的同一款程序可以运行在不同系统版本（向前兼容）、不同硬件平台、不同厂商制造的不同设备上。 CTS全称 Compatibility Test Suite 兼容性测试工具 让APP提供更好的用户体验。用户可以选择更多的适合自己设备的APP。让APP更稳定。 让开发者设计更高质量的APP。 通过CTS的设备可以运行Android market。 搭建测试环境 sudo apt install aapt 下载CTS工具包 DOWNLOAD 安装对应版本的 JDK cd 到目录android-cts/tools， 执行./cts-tradefed， 至此将进入CTS运行环境 常用测试命令 测试整个camera 1run cts -m CtsCameraTestCases 测试V8a或V7a 所有项 12run cts -m CtsCameraTestCases --abi xxx (arm64-v8a)run cts -m CtsCameraTestCases --abi xxx (armeabi-v7a) 单测某一项 1run cts -m CtsCameraTestCases -t xxx (android.hardware.camera2.cts.CaptureResultTest#testCameraCaptureResultAllKeys[1]) retry 命令 12l r #获取测试sessionrun retry --retry sessionID -s 设备号 GSI 简介 描述GSI(Generic System Image)通用系统镜像是在所有安卓手机上可以通用的系统，不需要适配不同手机。 GSI需要刷谷歌镜像，用cts的测试报工具测试（img一般由供应商提供，或者google定期提供给手机厂商） 常用测试命令 刷镜像命令 12345adb reboot fastbootfastboot flash system system.imgfastboot reboot bootloaderfastboot -wfastboot reboot 常用测试命令 1run cts-on-gsi -m CtsCameraTestCases VTS 简介 描述VTS的全称是 Vendor Test Suite（供应商测试套件）。 安卓 Project Treble 中引入 Vendor Interface 的目的是将 Android Framework 与 HAL 分开，并通过 VTS 测试来对这些 Vendor Interface 进行测试以确保 HAL 的向前兼容。 VTS 类似 CTS，通过对 Vendor Interface 进行测试，确保同一个版本的 Android Framework 可以运行在不同 HAL 上，或不同 Android Framework 可以运行在 同一个 HAL 上。确保Framework / HAL 接口的一致性，可以直接对 Framework 进行升级而不用考虑 HAL 层的改动，从而缩短了用户手上设备得到系统升级 OTA 推送的时间。 VTS是要刷谷歌镜像和boot_debug.img,要用VTS的工具包测试 常用测试命令 刷镜像命令 123456adb reboot fastbootfastboot fash system system.imgfastboot reboot bootloaderfastboot flash boot bootdebug.imgfastboot -wfastboot reboot 常用测试命令 123run vts -m VtsHalCameraProviderV2_4Target --skip-preconditions -s f5e4190frun vts -m VtsHalCameraProviderV2_5Target --skip-preconditions -s f5e4190frun vts -m VtsHalCameraServiceV2_0Target --skip-preconditions -s f5e4190f XTS Debug 方法 选择一个FAIL项，开启对应的apk log (先分析apk哪里FAIL ,根据上层去分析底层) 选择测试项关键字 #test 前面的字段（上图高亮部分），在opengrok 上面搜索 开启对应log 1adb shell setprop log.tag.ExChrsTest VERBOSE log 开启之后开始单独测试该项目 博客推荐 https://zhuanlan.zhihu.com/p/28301953 https://cloud.tencent.com/developer/article/1662018","tags":[{"name":"XTS","slug":"XTS","permalink":"https://zh-wiki.github.io/tags/XTS/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"XTS 相关","slug":"技术研发/XTS-相关","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/XTS-%E7%9B%B8%E5%85%B3/"}]},{"title":"MTK Camera Bring Up","date":"2019-11-29T16:00:00.000Z","path":"undefined/技术研发/Camera Driver/MTK 平台/MTK Camera Bring Up/","text":"https://online.mediatek.com/_layouts/15/mol/portal/ext/ECMLogin.aspx?ReturnUrl=%2f_layouts%2f15%2fAuthenticate.aspx%3fSource%3d%252FFAQ&amp;Source=%2FFAQ&amp;confirm=true#/SW/FAQ21886 Camera Driver 文件概览 .tg {border-collapse:collapse;border-color:#ccc;border-spacing:0;} .tg td{background-color:#fff;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;word-break:normal;} .tg th{background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:1px;color:#333; font-family:Arial, sans-serif;font-size:14px;font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;} .tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle} .tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top} .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} 分类 路径 描述 配置文件 device/mediatek/${project}/PorjectConfig.mkKernel-4.4/arch/arm64/configs/ * defconfig * 应该是编译相关 Kernel Driver kernel-4.4/drivers/misc/mediatek/imgsensor/src/${platform}/ * mipi_raw *kernel-4.4/drivers/misc/mediatek/imgsensor/src/mt6763/imgsensor_sensor_list.c kernel-4.4/drivers/misc/mediatek/imgsensor/src/mt6763/imgsensor_sensor_list.hkernel-4.4/drivers/misc/mediatek/imgsensor/inc/kd_imgsensor.hkernel-4.4/drivers/misc/mediatek/imgsensor/src/mk6763/camera_hw/imgsensor_cofg_table.c 内核驱动相关 Hal Driver vendor/mediatek/proprietary/custom/${platform}/hal/imgsensor/ * mipi_raw */vendor/mediatek/proprietary/custom/${platform}/hal/imgsensor_src/sensorlist.cpp/vendor/mediatek/proprietary/custom/${platform}/hal/sendepfeature/ * mipi_raw */ Hal 驱动相关","tags":[{"name":"MTK Camera","slug":"MTK-Camera","permalink":"https://zh-wiki.github.io/tags/MTK-Camera/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"MTK 平台","slug":"技术研发/Camera-Driver/MTK-平台","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/MTK-%E5%B9%B3%E5%8F%B0/"}]},{"title":"高通 mm 架构介绍","date":"2019-11-29T16:00:00.000Z","path":"undefined/技术研发/Camera Driver/高通 MM/高通 mm 架构介绍/","text":"Camera Buf 流转 QCamera3 层数据流 在 configureStreamsPerfLocked 的时候new了一系列的数据通道，用来管理stream. 在 processCaptureRequest 的时候 ,主要做了3件事情：ChannelInit , ChannelStart, ChannelRequest INIT Channel 给数据通道进行 add_stream , 给下层传递两个重要的回调。 将 QCamera3Stream::dataNotifyCB() 传递给mm层 ，mm层调用该回调将数据传递给 QCamera3Stream层 将 streamCbRoutine 回调传递给 QcameraStream 层，用于将数据返回给 QCameraChannel 层 START Channel 启动一个 线程函数 QCamera3Stream::dataProcRoutine() 监听CMD进行数据处理，调用 mDataCB (Channel层的 streamRotation) 当mm层get到数据会调用 dataNotifyCB() ,该函数通过调用 QCamera3Stream::processDataNotify() 给 dataProcRoutine() 线程函数发送命令 MM 层数据流 在mm层主要是围绕两个线程进行流转 mm_camera_cmd_thread_launch() mm_camera_poll_thread_launch() 在QCamera3中，进行初始化的Channel的时候，会add_stream和config_stream , 在config的过程中 mm_stream_config() 会将上层传下来的回调进行映射。 mm_camera_poll_thread_launch 获取到 MM_CAMERA_POLL_TYPE_DATA 事件，会去判断是否有数据回调函数。(mm_stream_data_notify) 在这个函数主要进行读数据，读完数据创建线程命令 MM_CAMERA_CMD_TYPE_DATA_CB ，最终调用 mm_stream_dispatch_app_data() 将数据上传。 高通camera daemon进程 iface_thread_main_loop 线程主要监听 proc 命令 和 kernel v4l2 事件 iface_thread_proc_cmd() iface_axi_proc_subdev_event() 当kernel出一帧数据就会触发 ISP_EVENT_SOF 事件 ，调用该函数 iface_axi_handle_sof_event() 进行数据处理 博客推荐 https://www.jianshu.com/p/ecb1be82e6a8 https://www.jianshu.com/p/1baad2a5281d https://wenku.baidu.com/view/3b408a6159fb770bf78a6529647d27284b733702.html","tags":[{"name":"高通 mm","slug":"高通-mm","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9A-mm/"}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 MM","slug":"技术研发/Camera-Driver/高通-MM","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-MM/"}]}],"categories":[{"name":"技术研发","slug":"技术研发","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/"},{"name":"Camera 专业知识","slug":"技术研发/Camera-专业知识","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/"},{"name":"XTS 相关","slug":"技术研发/XTS-相关","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/XTS-%E7%9B%B8%E5%85%B3/"},{"name":"生活学习","slug":"生活学习","permalink":"https://zh-wiki.github.io/categories/%E7%94%9F%E6%B4%BB%E5%AD%A6%E4%B9%A0/"},{"name":"艺术","slug":"艺术","permalink":"https://zh-wiki.github.io/categories/%E8%89%BA%E6%9C%AF/"},{"name":"程序语言","slug":"程序语言","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/"},{"name":"UML","slug":"程序语言/UML","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/UML/"},{"name":"Camera Driver","slug":"技术研发/Camera-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/"},{"name":"高通 Camx","slug":"技术研发/Camera-Driver/高通-Camx","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-Camx/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://zh-wiki.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Linux 命令","slug":"技术研发/Linux-命令","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-%E5%91%BD%E4%BB%A4/"},{"name":"项目随笔","slug":"技术研发/项目随笔","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"},{"name":"Linux Driver","slug":"技术研发/Linux-Driver","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-Driver/"},{"name":"V4L2","slug":"技术研发/Linux-Driver/V4L2","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Linux-Driver/V4L2/"},{"name":"Android 研发总结","slug":"技术研发/Android-研发总结","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Android-%E7%A0%94%E5%8F%91%E6%80%BB%E7%BB%93/"},{"name":"MarkDown","slug":"程序语言/MarkDown","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/MarkDown/"},{"name":"C++","slug":"程序语言/C","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/"},{"name":"设计模式","slug":"程序语言/C/设计模式","permalink":"https://zh-wiki.github.io/categories/%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"高通 MM","slug":"技术研发/Camera-Driver/高通-MM","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/%E9%AB%98%E9%80%9A-MM/"},{"name":"MTK 平台","slug":"技术研发/Camera-Driver/MTK-平台","permalink":"https://zh-wiki.github.io/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E5%8F%91/Camera-Driver/MTK-%E5%B9%B3%E5%8F%B0/"}],"tags":[{"name":"Camera","slug":"Camera","permalink":"https://zh-wiki.github.io/tags/Camera/"},{"name":"camera基础知识","slug":"camera基础知识","permalink":"https://zh-wiki.github.io/tags/camera%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"XTS","slug":"XTS","permalink":"https://zh-wiki.github.io/tags/XTS/"},{"name":"UML","slug":"UML","permalink":"https://zh-wiki.github.io/tags/UML/"},{"name":"高通Camx","slug":"高通Camx","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9ACamx/"},{"name":"Arch Linux","slug":"Arch-Linux","permalink":"https://zh-wiki.github.io/tags/Arch-Linux/"},{"name":"Centos","slug":"Centos","permalink":"https://zh-wiki.github.io/tags/Centos/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zh-wiki.github.io/tags/Hexo/"},{"name":"Linux 命令","slug":"Linux-命令","permalink":"https://zh-wiki.github.io/tags/Linux-%E5%91%BD%E4%BB%A4/"},{"name":"项目随笔","slug":"项目随笔","permalink":"https://zh-wiki.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%9A%8F%E7%AC%94/"},{"name":"V4L2","slug":"V4L2","permalink":"https://zh-wiki.github.io/tags/V4L2/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zh-wiki.github.io/tags/Ubuntu/"},{"name":"Android","slug":"Android","permalink":"https://zh-wiki.github.io/tags/Android/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://zh-wiki.github.io/tags/MarkDown/"},{"name":"设计模式","slug":"设计模式","permalink":"https://zh-wiki.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"高通 mm","slug":"高通-mm","permalink":"https://zh-wiki.github.io/tags/%E9%AB%98%E9%80%9A-mm/"},{"name":"MTK Camera","slug":"MTK-Camera","permalink":"https://zh-wiki.github.io/tags/MTK-Camera/"}]}